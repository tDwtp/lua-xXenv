<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html>
	<head>
		<link rel="stylesheet" href="stylesheet.css" type="text/css"/>
	</head>
<body>
<div id="container">
<div id="product">
	<div id="product_logo"></div>
	<div id="product_name"><big><b></b></big></div>
	<div id="product_description"></div>
</div>
<div id="main">
	<div id="navigation">
		<h2>Modules</h2>
			<ul><li>
				<a href="index.html">index</a>
			</li></ul>
		<ul>
					<li><a href="base64.html">base64</a></li>
					<li><a href="bit.html">bit</a></li>
					<li><a href="coroutine.html">coroutine</a></li>
					<li><a href="debug.html">debug</a></li>
					<li><a href="des56.html">des56</a></li>
					<li><a href="ex.html">ex</a></li>
					<li><a href="global.html">global</a></li>
					<li><a href="io.html">io</a></li>
					<li><a href="lfs.html">lfs</a></li>
					<li><a href="ltn12.html">ltn12</a></li>
					<li><a href="luacurl.html">luacurl</a></li>
					<li><a href="luasql.html">luasql</a></li>
					<li><a href="math.html">math</a></li>
					<li><a href="md5.html">md5</a></li>
					<li><a href="mime.html">mime</a></li>
					<li><a href="os.html">os</a></li>
					<li><a href="package.html">package</a></li>
					<li>socket</li>
					<li><a href="socket.ftp.html">socket.ftp</a></li>
					<li><a href="socket.http.html">socket.http</a></li>
					<li><a href="socket.smtp.html">socket.smtp</a></li>
					<li><a href="socket.url.html">socket.url</a></li>
					<li><a href="string.html">string</a></li>
					<li><a href="table.html">table</a></li>
					<li><a href="wx.html">wx</a></li>
					<li><a href="wxaui.html">wxaui</a></li>
					<li><a href="wxlua.html">wxlua</a></li>
					<li><a href="wxstc.html">wxstc</a></li>
		</ul>
	</div>
	<div id="content">
   <h1>Module <code>socket</code></h1>
   
<p>The socket namespace contains the core functionality of LuaSocket.</p>

   

<p>To obtain the socket namespace, run:
   -- loads the socket module 
   local socket = require("socket")</p>

	<h2><a id="#(socket)" >Type <code>socket</code></a></h2>
		<table class="function_list">
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(socket)._DEBUG">socket._DEBUG</a></td>
		<td class="summary">
<p>This constant is set to <code>true</code> if the library was compiled with debug support.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(socket)._VERSION">socket._VERSION</a></td>
		<td class="summary">
<p>This constant has a string describing the current LuaSocket version.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(socket).bind">socket.bind(host, port, backlog_or_hook)</a></td>
		<td class="summary">
<p>This function is a shortcut that creates and returns a TCP server object bound to a local address and port, 
ready to accept client connections.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(socket).connect">socket.connect(address, port, locaddr, locport)</a></td>
		<td class="summary">
<p>This function is a shortcut that creates and returns a TCP client object 
connected to a remote host at a given port.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(socket).dns">socket.dns</a></td>
		<td class="summary">
<p>DNS utilities.</p>

</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(socket).gettime">socket.gettime()</a></td>
		<td class="summary">
<p>Gives time</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(socket).newtry">socket.newtry(finalizer)</a></td>
		<td class="summary">
<p>Creates and returns a clean <a href="##(socket).try">socket.try</a> function that allows for cleanup
before the exception is raised.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(socket).protect">socket.protect(func)</a></td>
		<td class="summary">
<p>Converts a function that throws exceptions into a safe function.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(socket).select">socket.select(recvt, sendt, timeout)</a></td>
		<td class="summary">
<p>Waits for a number of sockets to change status.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(socket).sink">socket.sink(mode, socket, d, vararg)</a></td>
		<td class="summary">
<p>Creates an <a href="http://lua-users.org/wiki/FiltersSourcesAndSinks">LTN12</a> sink from a stream socket object.</p>

</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(socket).sleep">socket.sleep(time)</a></td>
		<td class="summary">
<p>Freezes the program execution during a given amount of time.</p>

</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(socket).source">socket.source(mode, socket)</a></td>
		<td class="summary">
<p>Creates an <a href="http://lua-users.org/wiki/FiltersSourcesAndSinks">LTN12</a> source from a stream socket object.</p>

</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(socket).tcp">socket.tcp()</a></td>
		<td class="summary">
<p>Creates and returns a TCP master object.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(socket).try">socket.try(...)</a></td>
		<td class="summary">
<p>Throws an exception in case of error.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(socket).udp">socket.udp()</a></td>
		<td class="summary">
<p>Creates and returns an unconnected UDP object.</p>
</td>
		</tr>
	</table>

			<h2><a id="#(client)">Type <code>client</code></a></h2>
				<table class="function_list">
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(client).close">client:close()</a></td>
		<td class="summary">
<p>As in <a href="##(server).bind">server.bind</a>.</p>

</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(client).getpeername">client:getpeername()</a></td>
		<td class="summary">
<p>Returns information about the remote side of a connected client object.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(client).getsockname">client:getsockname()</a></td>
		<td class="summary">
<p>As in <a href="##(server).getsockname">server.getsockname</a>.</p>

</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(client).getstats">client:getstats()</a></td>
		<td class="summary">
<p>As in <a href="##(server).getstats">server.getstats</a>.</p>

</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(client).receive">client:receive(pattern, prefix)</a></td>
		<td class="summary">
<p>Reads data from a client object, according to the specified read pattern.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(client).send">client:send(data, i, j)</a></td>
		<td class="summary">
<p>Sends data through client object.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(client).setoption">client:setoption(option, value)</a></td>
		<td class="summary">
<p>As in <a href="##(server).setoption">server.setoption</a>.</p>

</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(client).setstats">client:setstats(received, sent, age)</a></td>
		<td class="summary">
<p>As in <a href="##(server).setstats">server.setstats</a>.</p>

</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(client).settimeout">client:settimeout(value, mode)</a></td>
		<td class="summary">
<p>As in <a href="##(server).settimeout">server.settimeout</a>.</p>

</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(client).shutdown">client:shutdown(mode)</a></td>
		<td class="summary">
<p>Shuts down part of a full-duplex connection.</p>

</td>
		</tr>
	</table>

			<h2><a id="#(connected)">Type <code>connected</code></a></h2>
				<table class="function_list">
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(connected).close">connected:close()</a></td>
		<td class="summary">
<p>As in <a href="##(unconnected).close">unconnected.close</a>.</p>

</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(connected).getpeername">connected:getpeername()</a></td>
		<td class="summary">
<p>Retrieves information about the peer associated with a connected UDP object.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(connected).getsockname">connected:getsockname()</a></td>
		<td class="summary">
<p>As in <a href="##(unconnected).getsockname">unconnected.getsockname</a>.</p>

</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(connected).receive">connected:receive(size)</a></td>
		<td class="summary">
<p>As in <a href="##(unconnected).receive">unconnected.receive</a>.</p>

</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(connected).send">connected:send(datagram)</a></td>
		<td class="summary">
<p>Sends a datagram to the UDP peer of a connected object.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(connected).setoption">connected:setoption(value)</a></td>
		<td class="summary">
<p> As in <a href="##(unconnected).setoption">unconnected.setoption</a>.</p>

</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(connected).setpeername">connected:setpeername(address, port)</a></td>
		<td class="summary">
<p>Changes the peer of a UDP object.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(connected).settimeout">connected:settimeout(value)</a></td>
		<td class="summary">
<p>As in <a href="##(unconnected).settimeout">unconnected.settimeout</a>.</p>

</td>
		</tr>
	</table>

			<h2><a id="#(dns)">Type <code>dns</code></a></h2>
				<table class="function_list">
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(dns).gethostname">dns.gethostname()</a></td>
		<td class="summary">
<p>The standard host name </p>

</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(dns).tohostname">dns.tohostname(address)</a></td>
		<td class="summary">
<p>Converts from IP address to host name.</p>

</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(dns).toip">dns.toip(address)</a></td>
		<td class="summary">
<p>Converts from host name to IP address.</p>

</td>
		</tr>
	</table>

			<h2><a id="#(master)">Type <code>master</code></a></h2>
				<table class="function_list">
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(master).close">master:close()</a></td>
		<td class="summary">
<p>As in <a href="##(server).bind">server.bind</a>.</p>

</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(master).connect">master:connect(address, port)</a></td>
		<td class="summary">
<p>Attempts to connect a master object to a remote host, transforming it into a
client object.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(master).getsockname">master:getsockname()</a></td>
		<td class="summary">
<p>As in <a href="##(server).getsockname">server.getsockname</a>.</p>

</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(master).getstats">master:getstats()</a></td>
		<td class="summary">
<p>As in <a href="##(server).getstats">server.getstats</a>.</p>

</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(master).listen">master:listen(backlog)</a></td>
		<td class="summary">
<p>Specifies the socket is willing to receive connections, transforming the object into a server object.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(master).setstats">master:setstats(received, sent, age)</a></td>
		<td class="summary">
<p>As in <a href="##(server).setstats">server.setstats</a>.</p>

</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(master).settimeout">master:settimeout(value, mode)</a></td>
		<td class="summary">
<p>As in <a href="##(server).settimeout">server.settimeout</a>.</p>

</td>
		</tr>
	</table>

			<h2><a id="#(server)">Type <code>server</code></a></h2>
				<table class="function_list">
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(server).accept">server:accept()</a></td>
		<td class="summary">
<p>Waits for a remote connection on the server object and returns a <a href="##(client)">#client</a> object representing that connection.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(server).close">server:close()</a></td>
		<td class="summary">
<p>Closes a TCP object.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(server).getsockname">server:getsockname()</a></td>
		<td class="summary">
<p>Returns the local address information associated to the object.</p>

</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(server).getstats">server:getstats()</a></td>
		<td class="summary">
<p>Returns accounting information on the socket, useful for throttling of bandwidth.</p>

</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(server).setoption">server:setoption(option, value)</a></td>
		<td class="summary">
<p>Sets options for the TCP object.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(server).setstats">server:setstats(received, sent, age)</a></td>
		<td class="summary">
<p>Resets accounting information on the socket, useful for throttling of bandwidth.</p>

</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(server).settimeout">server:settimeout(value, mode)</a></td>
		<td class="summary">
<p>Changes the timeout values for the object.</p>
</td>
		</tr>
	</table>

			<h2><a id="#(unconnected)">Type <code>unconnected</code></a></h2>
				<table class="function_list">
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(unconnected).close">unconnected:close()</a></td>
		<td class="summary">
<p>Closes a UDP object.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(unconnected).getsockname">unconnected:getsockname()</a></td>
		<td class="summary">
<p>Returns the local address information associated to the object.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(unconnected).receive">unconnected:receive(size)</a></td>
		<td class="summary">
<p>Receives a datagram from the UDP object.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(unconnected).receivefrom">unconnected:receivefrom(size)</a></td>
		<td class="summary">
<p>Works exactly as the <a href="##(unconnected).receive">unconnected.receive</a> method, except it returns the IP
address and port as extra return values (and is therefore slightly less
efficient).</p>

</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(unconnected).sendto">unconnected:sendto(datagram, ip, port)</a></td>
		<td class="summary">
<p>Sends a datagram to the specified IP address and port number.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(unconnected).setoption">unconnected.setoption(option, value)</a></td>
		<td class="summary">
<p>Sets options for the UDP object.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(unconnected).setpeername">unconnected:setpeername(address, port)</a></td>
		<td class="summary">
<p>As in <a href="##(connected).setpeername">connected.setpeername</a>.</p>

</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(unconnected).setsockname">unconnected:setsockname(address, port)</a></td>
		<td class="summary">
<p>Binds the UDP object to a local address.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(unconnected).settimeout">unconnected:settimeout(value)</a></td>
		<td class="summary">
<p>Changes the timeout values for the object.</p>
</td>
		</tr>
	</table>

	<h2><a id="#(socket)" >Type <code>socket</code></a></h2>
		<h3>Field(s)</h3>
		<dl class="function">
<dt>

		<em>#boolean</em>
<a id="#(socket)._DEBUG" >
<strong>socket._DEBUG</strong>
</a>
</dt>
<dd>
	
<p>This constant is set to <code>true</code> if the library was compiled with debug support.</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#string</em>
<a id="#(socket)._VERSION" >
<strong>socket._VERSION</strong>
</a>
</dt>
<dd>
	
<p>This constant has a string describing the current LuaSocket version.</p>

</dd>
</dl>
		<dl class="function">
<dt>

<a id="#(socket).bind" >
<strong>socket.bind(host, port, backlog_or_hook)</strong>
</a>
</dt>
<dd>
	
<p>This function is a shortcut that creates and returns a TCP server object bound to a local address and port, 
ready to accept client connections.</p>

	
<p>Modified from the original Luasocket function to support an optional hook argument.</p>


		<h3>Parameters</h3>
		<ul>
				<li>
				
<p><code><em> host </em></code>: 
local address to bind to</p>

				</li>
				<li>
				
<p><code><em> port </em></code>: 
local port to bind</p>

				</li>
				<li>
				
<p><code><em> backlog<em>or</em>hook </em></code>: 
 Optionally, user can also specify the backlog argument to the listen method (defaults to 32).
 This third parameter can also be the hook if no backlog parameter  is given.
-@param hook is an additional parameter (not compatible with luasocket original socket.bind()</p>

				</li>
		</ul>
		<h3>Return value</h3>
				

<p>TCP server object</p>

			<h3>Usages:</h3>
		<ul>
			<li><pre class="example"><code>socket.bind("someaddress", 4242, function hook(...) end)</code></pre></li>
			<li><pre class="example"><code>socket.bind("someaddress", 4242, 32,function hook(...) end)
</code></pre></li>
		</ul>

</dd>
</dl>
		<dl class="function">
<dt>

<a id="#(socket).connect" >
<strong>socket.connect(address, port, locaddr, locport)</strong>
</a>
</dt>
<dd>
	
<p>This function is a shortcut that creates and returns a TCP client object 
connected to a remote host at a given port.</p>

	

<p>Optionally, the user can also specify the local address and port to bind 
(<code>locaddr</code> and <code>locport</code>).</p>


		<h3>Parameters</h3>
		<ul>
				<li>
				
<p><code><em> address </em></code>: 
address to connect to</p>

				</li>
				<li>
				
<p><code><em> port </em></code>: 
port</p>

				</li>
				<li>
				
<p><code><em> locaddr </em></code>: 
optional local address to bind</p>

				</li>
				<li>
				
<p><code><em> locport </em></code>: 
optional local port to bind</p>

				</li>
		</ul>
		<h3>Return value</h3>
				

<p>TCP client object</p>


</dd>
</dl>
		<dl class="function">
<dt>

		<em><a href="##(dns)">#dns</a></em>
<a id="#(socket).dns" >
<strong>socket.dns</strong>
</a>
</dt>
<dd>
	
<p>DNS utilities.</p>


</dd>
</dl>
		<dl class="function">
<dt>

<a id="#(socket).gettime" >
<strong>socket.gettime()</strong>
</a>
</dt>
<dd>
	
<p>Gives time</p>

		<h3>Return value</h3>
				

<p>The time in seconds, relative to the origin of the universe. 
You should subtract the values returned by this function to get meaningful values.</p>


			<h3>Usage:</h3>
		<pre class="example"><code>t = socket.gettime()
-- do stuff
print(socket.gettime() - t .. " seconds elapsed")
	</code></pre>

</dd>
</dl>
		<dl class="function">
<dt>

<a id="#(socket).newtry" >
<strong>socket.newtry(finalizer)</strong>
</a>
</dt>
<dd>
	
<p>Creates and returns a clean <a href="##(socket).try">socket.try</a> function that allows for cleanup
before the exception is raised.</p>

	

<p><code>finalizer</code> is a function that will be called before try throws the exception. 
It will be called in protected mode.</p>

<p>The function returns your customized <a href="##(socket).try">socket.try</a> function.</p>

<p>Note: This idea saved a lot of work with the implementation of protocols 
in LuaSocket:</p>
<pre><code>foo = socket.protect(function()
    -- connect somewhere
    local c = socket.try(socket.connect("somewhere", 42))
    -- create a try function that closes 'c' on error
    local try = socket.newtry(function() c:close() end)
    -- do everything reassured c will be closed 
    try(c:send("hello there?\r\n"))
    local answer = try(c:receive())
    ...
    try(c:send("good bye\r\n"))
    c:close()
 end)
</code></pre>


		<h3>Parameter</h3>
		<ul>
				<li>
				
<p><code><em> finalizer </em></code>: 
function that will be called before try throws the exception.</p>

				</li>
		</ul>
		<h3>Return value</h3>
				

<p>a customized <a href="##(socket).try">socket.try</a> function</p>


</dd>
</dl>
		<dl class="function">
<dt>

<a id="#(socket).protect" >
<strong>socket.protect(func)</strong>
</a>
</dt>
<dd>
	
<p>Converts a function that throws exceptions into a safe function.</p>

	

<p>This function only catches exceptions thrown by the <a href="##(socket).try">socket.try</a> 
and <a href="##(socket).newtry">socket.newtry</a> functions. 
It does not catch normal Lua errors.</p>

<p><code>func</code> is a function that calls <a href="##(socket).try">socket.try</a> (or <code>assert</code>, or <code>error</code>) 
 to throw exceptions.</p>

<p>Returns an equivalent function that instead of throwing exceptions, 
returns <code>nil</code> followed by an error message.</p>

<p>Note: Beware that if your function performs some illegal operation that raises an error, the protected function will catch the error and return it as a string. This is because the try function uses errors as the mechanism to throw exceptions.</p>


		<h3>Parameter</h3>
		<ul>
				<li>
				
<p><code><em> func </em></code>: 
function that calls <a href="##(socket).try">socket.try</a> (or <code>assert</code>, or <code>error</code>) 
 to throw exceptions.</p>

				</li>
		</ul>
		<h3>Return value</h3>
				

<p>an equivalent function that instead of throwing exceptions, 
 returns <code>nil</code> followed by an error message</p>


</dd>
</dl>
		<dl class="function">
<dt>

<a id="#(socket).select" >
<strong>socket.select(recvt, sendt, timeout)</strong>
</a>
</dt>
<dd>
	
<p>Waits for a number of sockets to change status.</p>

	

<p><code>Recvt</code> is an array with the sockets to test for characters available 
for reading.
Sockets in the <code>sendt</code> array are watched to see if it is OK 
to immediately write on them.
<code>Timeout</code> is the maximum amount of time (in seconds) to wait for a change
in status. A <code>nil</code>, negative or omitted <code>timeout</code> value allows the function
to block indefinitely.
<code>Recvt</code> and <code>sendt</code> can also be empty tables or <code>nil</code>.
Non-socket values (or values with non-numeric indices) in the arrays
will be silently ignored.</p>

<p>The function returns a list with the sockets ready for reading,
a list with the sockets ready for writing and an error message.
The error message is "timeout" if a timeout condition was met and <code>nil</code> otherwise.
The returned tables are doubly keyed both by integers and also by the sockets 
themselves, to simplify the test if a specific socket has changed status.</p>

<ul>
    <li><p><strong>Important note</strong>: a known bug in WinSock causes select to fail 
    on non-blocking TCP sockets. The function may return a socket as writable 
    even though the socket is not ready for sending.</p></li>
    <li><p><strong>Another important note</strong>: calling select with a server socket
    in the receive parameter before a call to <a href="##(server).accept">server.accept</a> does not 
    guarantee accept will return immediately. 
    Use the settimeout method or accept might block forever.</p></li>
    <li><p><strong>Yet another note</strong>: If you close a socket and pass it to select, 
    it will be ignored.</p></li>
</ul>


		<h3>Parameters</h3>
		<ul>
				<li>
				
<p><code><em> recvt </em></code>: 
an array with the sockets to test for characters available 
 for reading. Can also be empty table or nil. Non-socket values 
 (or values with non-numeric indices) in the array will be silently ignored.</p>

				</li>
				<li>
				
<p><code><em> sendt </em></code>: 
an array of sockets that are watched to see if it is OK
 to immediately write on them. Can also be empty table or nil. Non-socket values 
 (or values with non-numeric indices) in the array will be silently ignored. </p>

				</li>
				<li>
				
<p><code><em> timeout </em></code>: 
optional maximum amount of time (in seconds) 
 to wait for a change in status.
 A nil, negative or omitted timeout value allows the function to block indefinitely. </p>

				</li>
		</ul>
		<h3>Return value</h3>
				

<p>a list with the sockets ready for reading,
a list with the sockets ready for writing and an error message.</p>


</dd>
</dl>
		<dl class="function">
<dt>

<a id="#(socket).sink" >
<strong>socket.sink(mode, socket, d, vararg)</strong>
</a>
</dt>
<dd>
	
<p>Creates an <a href="http://lua-users.org/wiki/FiltersSourcesAndSinks">LTN12</a> sink from a stream socket object.</p>


		<h3>Parameters</h3>
		<ul>
				<li>
				
<p><code><em> mode </em></code>: 
Defines the behavior of the sink. The following options are available:</p>

<ul>
    <li><strong>"http-chunked"</strong>: sends data through socket after applying the chunked transfer coding, closing the socket when done;</li>
    <li><strong>"close-when-done"</strong>: sends all received data through the socket, closing the socket when done;</li>
    <li><strong>"keep-open"</strong>: sends all received data through the socket, leaving it open when done.</li>
</ul>

				</li>
				<li>
				
<p><code><em> socket </em></code>: 
The stream socket object used to send the data.</p>

				</li>
				<li>
				
<p><code><em> d </em></code>: 
The number of arguments to drop. </p>

				</li>
				<li>
				
<p><code><em> vararg </em></code>: 
The arguments.</p>

				</li>
		</ul>
		<h3>Return values</h3>
			<ol>
				<li>
				

<p>A sink with the appropriate behavior.</p>

<hr/>
<p>Drops a number of arguments and returns the remaining.
Note: This function is useful to avoid creation of dummy variables:</p>

<p>   -- get the status code and separator from SMTP server reply 
   local code, sep = socket.skip(2, string.find(line, "^(%d%d%d)(.?)"))</p>


				</li>
				<li>
				

<p> ret<sub>d+1</sub> to ret<sub>n</sub>.</p>


				</li>
			</ol>
</dd>
</dl>
		<dl class="function">
<dt>

<a id="#(socket).sleep" >
<strong>socket.sleep(time)</strong>
</a>
</dt>
<dd>
	
<p>Freezes the program execution during a given amount of time.</p>


		<h3>Parameter</h3>
		<ul>
				<li>
				
<p><code><em>#number time </em></code>: 
Number of seconds to sleep for. The function truncates time down to the nearest integer.</p>


				</li>
		</ul>
</dd>
</dl>
		<dl class="function">
<dt>

<a id="#(socket).source" >
<strong>socket.source(mode, socket)</strong>
</a>
</dt>
<dd>
	
<p>Creates an <a href="http://lua-users.org/wiki/FiltersSourcesAndSinks">LTN12</a> source from a stream socket object.</p>


		<h3>Parameters</h3>
		<ul>
				<li>
				
<p><code><em> mode </em></code>: 
Defines the behavior of the source. The following options are available:</p>

<ul>
    <li><strong>"http-chunked"</strong>: receives data from socket and removes the chunked transfer coding before returning the data;</li>
    <li><strong>"by-length"</strong>: receives a fixed number of bytes from the socket. This mode requires the extra argument length;</li>
    <li><strong>"until-closed"</strong>: receives data from a socket until the other side closes the connection.</li>
</ul>

				</li>
				<li>
				
<p><code><em> socket </em></code>: 
The stream socket object used to receive the data.</p>

				</li>
		</ul>
		<h3>Return value</h3>
				

<p>A source with the appropriate behavior.</p>


</dd>
</dl>
		<dl class="function">
<dt>

<a id="#(socket).tcp" >
<strong>socket.tcp()</strong>
</a>
</dt>
<dd>
	
<p>Creates and returns a TCP master object.</p>

	
<p>A master object can be transformed into a server object with the method listen (after a call to bind) or into a client object with the method connect. The only other method supported by a master object is the close method.</p>


		<h3>Return values</h3>
			<ol>
				<li>
				
<p><em><a href="##(master)">#master</a>:</em>
In case of success.</p>

				</li>
				<li>
				
<p><em>#nil, #string:</em>
In error cases, error string is provided.</p>


				</li>
			</ol>
</dd>
</dl>
		<dl class="function">
<dt>

<a id="#(socket).try" >
<strong>socket.try(...)</strong>
</a>
</dt>
<dd>
	
<p>Throws an exception in case of error.</p>

	
<p>The exception can only be caught by the protect function. It does not explode into an error message.</p>

		<h3>Parameter</h3>
		<ul>
				<li>
				
<p><code><em> ... </em></code>: 
Can be arbitrary arguments, but are usually the return values of a function call nested with try.</p>

				</li>
		</ul>
			<h3>Usage:</h3>
		<pre class="example"><code>-- connects or throws an exception with the appropriate error message
c = socket.try(socket.connect("localhost", 80))
</code></pre>

</dd>
</dl>
		<dl class="function">
<dt>

<a id="#(socket).udp" >
<strong>socket.udp()</strong>
</a>
</dt>
<dd>
	
<p>Creates and returns an unconnected UDP object.</p>

	

<p><a href="##(unconnected)">#unconnected</a> objects support the <a href="##(unconnected).sendto">unconnected.sendto</a>,
<a href="##(unconnected).receive">unconnected.receive</a>, <a href="##(unconnected).receivefrom">unconnected.receivefrom</a>,
<a href="##(unconnected).getsockname">unconnected.getsockname</a>, <a href="##(unconnected).setoption">unconnected.setoption</a>,
<a href="##(unconnected).settimeout">unconnected.settimeout</a>, <a href="##(unconnected).setpeername">unconnected.setpeername</a>,
<a href="##(unconnected).setsockname">unconnected.setsockname</a>, and <a href="##(unconnected).close">unconnected.close</a>. The 
<a href="##(unconnected).setpeername">unconnected.setpeername</a> is used to connect the object.</p>


		<h3>Return values</h3>
			<ol>
				<li>
				

<p>In case of success, a new unconnected UDP object returned.</p>

				</li>
				<li>
				
<p><em>#nil, #string:</em>
In case of error, nil is returned,
followed by an error message.</p>


				</li>
			</ol>
</dd>
</dl>

			<h2><a id="#(client)" >Type <code>client</code></a></h2>
				
<p>A TCP Client object.</p>


	<h3>Field(s)</h3>
		<dl class="function">
<dt>

<a id="#(client).close" >
<strong>client:close()</strong>
</a>
</dt>
<dd>
	
<p>As in <a href="##(server).bind">server.bind</a>.</p>


</dd>
</dl>
		<dl class="function">
<dt>

<a id="#(client).getpeername" >
<strong>client:getpeername()</strong>
</a>
</dt>
<dd>
	
<p>Returns information about the remote side of a connected client object.</p>

	

<p>Note: It makes no sense to call this method on <a href="##(server)">#server</a> objects.</p>


		<h3>Return values</h3>
			<ol>
				<li>
				
<p><em>#string:</em>
The IP address of the peer, followed by the port number that peer is using for the connection.</p>

				</li>
				<li>
				
<p><em>#nil:</em>
In case of error.</p>


				</li>
			</ol>
</dd>
</dl>
		<dl class="function">
<dt>

<a id="#(client).getsockname" >
<strong>client:getsockname()</strong>
</a>
</dt>
<dd>
	
<p>As in <a href="##(server).getsockname">server.getsockname</a>.</p>


</dd>
</dl>
		<dl class="function">
<dt>

<a id="#(client).getstats" >
<strong>client:getstats()</strong>
</a>
</dt>
<dd>
	
<p>As in <a href="##(server).getstats">server.getstats</a>.</p>


</dd>
</dl>
		<dl class="function">
<dt>

<a id="#(client).receive" >
<strong>client:receive(pattern, prefix)</strong>
</a>
</dt>
<dd>
	
<p>Reads data from a client object, according to the specified read pattern.</p>

	

<p>Patterns follow the Lua file I/O format, and the difference in performance
between all patterns is negligible.</p>

<p><strong>Important note</strong>: This function was changed severely. It used to support
multiple patterns (but I have never seen this feature used) and now it doesn't
anymore. Partial results used to be returned in the same way as successful
results. This last feature violated the idea that all functions should return
nil on error. Thus it was changed too.</p>


		<h3>Parameters</h3>
		<ul>
				<li>
				
<p><code><em> pattern </em></code>: 
can be any of the following:</p>

<ul>
    <li>'*a': reads from the socket until the connection is closed. No end-of-line translation is performed;</li>
    <li>'*l': reads a line of text from the socket. The line is terminated by a LF character (ASCII 10), optionally preceded by a CR character (ASCII 13). The CR and LF characters are not included in the returned line. In fact, all CR characters are ignored by the pattern. This is the default pattern;</li>
    <li>_<a href="##(number)">#number</a>_: causes the method to read a specified number of bytes from the socket.</li>
</ul>

				</li>
				<li>
				
<p><code><em>#string prefix </em></code>: 
(optional) An optional string to be concatenated to the beginning of any received data before return.</p>

				</li>
		</ul>
		<h3>Return values</h3>
			<ol>
				<li>
				

<p>If successful, the method returns the received pattern.</p>

				</li>
				<li>
				
<p><em>#nil, #string:</em>
In case of error, the method returns nil followed by an error message which can be:</p>

<ul>
    <li><strong>'closed'</strong>: In case the connection was closed before the transmission was completed.</li>
    <li><strong>'timeout'</strong>: In case there was a timeout during the operation.</li>
</ul>

<p> Also, after the error message, the function returns the partial result of the
 transmission.</p>


				</li>
			</ol>
</dd>
</dl>
		<dl class="function">
<dt>

<a id="#(client).send" >
<strong>client:send(data, i, j)</strong>
</a>
</dt>
<dd>
	
<p>Sends data through client object.</p>

	

<p>The optional arguments i and j work exactly like the standard
<a href="http://www.lua.org/manual/5.1/manual.html#pdf-string.sub">#string.sub</a> Lua
function to allow the selection of a substring to be sent.</p>

<p>Note: Output is not buffered. For small strings, it is always better to
concatenate them in Lua (with the '..' operator) and send the result in one
call instead of calling the method several times.</p>


		<h3>Parameters</h3>
		<ul>
				<li>
				
<p><code><em> data </em></code>: 
The string to be sent.</p>

				</li>
				<li>
				
<p><code><em>#number i </em></code>: 
(optional) As in <a href="http://www.lua.org/manual/5.1/manual.html#pdf-string.sub">#string.sub</a>.</p>

				</li>
				<li>
				
<p><code><em>#number j </em></code>: 
(optional) As in <a href="http://www.lua.org/manual/5.1/manual.html#pdf-string.sub">#string.sub</a>.</p>

				</li>
		</ul>
		<h3>Return values</h3>
			<ol>
				<li>
				

<p>If successful, the method returns the index of the last byte within
 [i, j] that has been sent. Notice that, if i is 1 or absent, this is
 effectively the total number of bytes sent.</p>

				</li>
				<li>
				
<p><em>#nil, #string, #number:</em>
In case of error, the method returns nil,
 followed by an error message, followed by the index of the last byte within
 [i, j] that has been sent. You might want to try again from the byte following
 that.
The error message can be:</p>

<ul>
    <li><strong>'closed'</strong>: In case the connection was closed before the transmission was
    completed.</li>
    <li><strong>'timeout'</strong>: In case there was a timeout during the operation.</li>
</ul>


				</li>
			</ol>
</dd>
</dl>
		<dl class="function">
<dt>

<a id="#(client).setoption" >
<strong>client:setoption(option, value)</strong>
</a>
</dt>
<dd>
	
<p>As in <a href="##(server).setoption">server.setoption</a>.</p>


		<h3>Parameters</h3>
		<ul>
				<li>
				
<p><code><em>#string option </em></code>: </p>

				</li>
				<li>
				
<p><code><em> value </em></code>: </p>

				</li>
		</ul>
</dd>
</dl>
		<dl class="function">
<dt>

<a id="#(client).setstats" >
<strong>client:setstats(received, sent, age)</strong>
</a>
</dt>
<dd>
	
<p>As in <a href="##(server).setstats">server.setstats</a>.</p>


		<h3>Parameters</h3>
		<ul>
				<li>
				
<p><code><em>#number received </em></code>: </p>

				</li>
				<li>
				
<p><code><em>#number sent </em></code>: </p>

				</li>
				<li>
				
<p><code><em>#number age </em></code>: </p>

				</li>
		</ul>
</dd>
</dl>
		<dl class="function">
<dt>

<a id="#(client).settimeout" >
<strong>client:settimeout(value, mode)</strong>
</a>
</dt>
<dd>
	
<p>As in <a href="##(server).settimeout">server.settimeout</a>.</p>


		<h3>Parameters</h3>
		<ul>
				<li>
				
<p><code><em>#number value </em></code>: </p>

				</li>
				<li>
				
<p><code><em>#string mode </em></code>: </p>

				</li>
		</ul>
</dd>
</dl>
		<dl class="function">
<dt>

<a id="#(client).shutdown" >
<strong>client:shutdown(mode)</strong>
</a>
</dt>
<dd>
	
<p>Shuts down part of a full-duplex connection.</p>


		<h3>Parameter</h3>
		<ul>
				<li>
				
<p><code><em>#string mode </em></code>: 
Tells which way of the connection should be shut down and
 can take the value:</p>

<ul>
    <li>"both": disallow further sends and receives on the object. This is the default mode;</li>
    <li>"send": disallow further sends on the object;</li>
    <li>"receive": disallow further receives on the object.</li>
</ul>

				</li>
		</ul>
		<h3>Return value</h3>
				
<p><em>#number:</em>
This function returns 1.</p>


</dd>
</dl>

			<h2><a id="#(connected)" >Type <code>connected</code></a></h2>
				
<p>A connected UDP object.</p>


	<h3>Field(s)</h3>
		<dl class="function">
<dt>

<a id="#(connected).close" >
<strong>connected:close()</strong>
</a>
</dt>
<dd>
	
<p>As in <a href="##(unconnected).close">unconnected.close</a>.</p>


</dd>
</dl>
		<dl class="function">
<dt>

<a id="#(connected).getpeername" >
<strong>connected:getpeername()</strong>
</a>
</dt>
<dd>
	
<p>Retrieves information about the peer associated with a connected UDP object.</p>

	

<p>Note: It makes no sense to call this method on unconnected objects.</p>


		<h3>Return value</h3>
				

<p>The IP address and port number of the peer.</p>


</dd>
</dl>
		<dl class="function">
<dt>

<a id="#(connected).getsockname" >
<strong>connected:getsockname()</strong>
</a>
</dt>
<dd>
	
<p>As in <a href="##(unconnected).getsockname">unconnected.getsockname</a>.</p>


</dd>
</dl>
		<dl class="function">
<dt>

<a id="#(connected).receive" >
<strong>connected:receive(size)</strong>
</a>
</dt>
<dd>
	
<p>As in <a href="##(unconnected).receive">unconnected.receive</a>.</p>


		<h3>Parameter</h3>
		<ul>
				<li>
				
<p><code><em> size </em></code>: </p>

				</li>
		</ul>
</dd>
</dl>
		<dl class="function">
<dt>

<a id="#(connected).send" >
<strong>connected:send(datagram)</strong>
</a>
</dt>
<dd>
	
<p>Sends a datagram to the UDP peer of a connected object.</p>

	

<p>Note: In UDP, the send method never blocks and the only way it can fail is if
the underlying transport layer refuses to send a message to the specified
address (i.e. no interface accepts the address).
 </p>

		<h3>Parameter</h3>
		<ul>
				<li>
				
<p><code><em> datagram </em></code>: 
A <em>#string</em> with the datagram contents. The maximum datagram
 size for UDP is 64K minus IP layer overhead. However datagrams larger than the
 link layer packet size will be fragmented, which may deteriorate performance
 and/or reliability.</p>

				</li>
		</ul>
		<h3>Return values</h3>
			<ol>
				<li>
				
<p><em>#number:</em>
1, in case of success.</p>

				</li>
				<li>
				
<p><em>#nil, #string:</em>
In error cases, error string is provided.</p>


				</li>
			</ol>
</dd>
</dl>
		<dl class="function">
<dt>

<a id="#(connected).setoption" >
<strong>connected:setoption(value)</strong>
</a>
</dt>
<dd>
	
<p> As in <a href="##(unconnected).setoption">unconnected.setoption</a>.</p>


		<h3>Parameter</h3>
		<ul>
				<li>
				
<p><code><em> value </em></code>: </p>

				</li>
		</ul>
</dd>
</dl>
		<dl class="function">
<dt>

<a id="#(connected).setpeername" >
<strong>connected:setpeername(address, port)</strong>
</a>
</dt>
<dd>
	
<p>Changes the peer of a UDP object.</p>

	

<p>This method turns an unconnected UDP object into a connected UDP object or vice
versa. Outgoing datagrams will be sent to the specified peer, and datagrams
received from other peers will be discarded by the OS. Connected UDP objects
must use the <a href="unconnected.html##(send)">unconnected#send</a> and <a href="connected.html##(receive)">connected#receive</a> methods instead of
<a href="unconnected.html##(sendto)">unconnected#sendto</a> and <a href="##(unconnected).receivefrom">unconnected.receivefrom</a>.</p>

<p>Note: Since the address of the peer does not have to be passed to and from the
OS, the use of connected UDP objects is recommended when the same peer is used
for several transmissions and can result in up to 30% performance gains.</p>


		<h3>Parameters</h3>
		<ul>
				<li>
				
<p><code><em>#string address </em></code>: 
Can be an IP address or a host name. If address is
 <strong>'*'</strong> and the object is connected, the peer association is removed and the
 object becomes an unconnected object again. In that case, the port argument is
 ignored.</p>

				</li>
				<li>
				
<p><code><em>#number port </em></code>: 
The port number.</p>

				</li>
		</ul>
		<h3>Return values</h3>
			<ol>
				<li>
				
<p><em>#number:</em>
1, in case of success.</p>

				</li>
				<li>
				
<p><em>#nil, #string:</em>
In error cases, error string is provided.</p>


				</li>
			</ol>
</dd>
</dl>
		<dl class="function">
<dt>

<a id="#(connected).settimeout" >
<strong>connected:settimeout(value)</strong>
</a>
</dt>
<dd>
	
<p>As in <a href="##(unconnected).settimeout">unconnected.settimeout</a>.</p>


		<h3>Parameter</h3>
		<ul>
				<li>
				
<p><code><em>#number value </em></code>: </p>

				</li>
		</ul>
</dd>
</dl>

			<h2><a id="#(dns)" >Type <code>dns</code></a></h2>
				
<p>Name resolution functions return all information obtained from the resolver in a table of the form:</p>

<pre><code>resolved = {
    name = canonic-name,
    alias = alias-list,
    ip = ip-address-list
}
</code></pre>

<p>Note that the alias list can be empty.</p>

	<h3>Field(s)</h3>
		<dl class="function">
<dt>

<a id="#(dns).gethostname" >
<strong>dns.gethostname()</strong>
</a>
</dt>
<dd>
	
<p>The standard host name </p>


		<h3>Return value</h3>
				
<p><em>#string:</em>
The standard host name for the machine.</p>


</dd>
</dl>
		<dl class="function">
<dt>

<a id="#(dns).tohostname" >
<strong>dns.tohostname(address)</strong>
</a>
</dt>
<dd>
	
<p>Converts from IP address to host name.</p>


		<h3>Parameter</h3>
		<ul>
				<li>
				
<p><code><em>#string address </em></code>: 
Can be an IP address or host name.</p>

				</li>
		</ul>
		<h3>Return values</h3>
			<ol>
				<li>
				
<p><em>#string:</em>
The canonic host name of the given <em>address</em>, followed by a
 table with all information returned by the resolver. </p>

				</li>
				<li>
				
<p><em>#nil, #string:</em>
In error cases, error string is provided.</p>


				</li>
			</ol>
</dd>
</dl>
		<dl class="function">
<dt>

<a id="#(dns).toip" >
<strong>dns.toip(address)</strong>
</a>
</dt>
<dd>
	
<p>Converts from host name to IP address.</p>


		<h3>Parameter</h3>
		<ul>
				<li>
				
<p><code><em>#string address </em></code>: 
Can be an IP address or host name.</p>

				</li>
		</ul>
		<h3>Return values</h3>
			<ol>
				<li>
				
<p><em>#string, #table:</em>
The first IP address found for address, followed by a
 table with all information returned by the resolver.</p>

				</li>
				<li>
				
<p><em>#nil, #string:</em>
In error cases, error string is provided.</p>


				</li>
			</ol>
</dd>
</dl>

			<h2><a id="#(master)" >Type <code>master</code></a></h2>
				
<p>A TCP Master object.</p>


	<h3>Field(s)</h3>
		<dl class="function">
<dt>

<a id="#(master).close" >
<strong>master:close()</strong>
</a>
</dt>
<dd>
	
<p>As in <a href="##(server).bind">server.bind</a>.</p>


</dd>
</dl>
		<dl class="function">
<dt>

<a id="#(master).connect" >
<strong>master:connect(address, port)</strong>
</a>
</dt>
<dd>
	
<p>Attempts to connect a master object to a remote host, transforming it into a
client object.</p>

	

<p>Client objects support methods <a href="##(client).send">client.send</a>, <a href="##(client).receive">client.receive</a>,
<a href="##(server).getsockname">server.getsockname</a>,  <a href="##(client).getpeername">client.getpeername</a>,  <a href="##(server).settimeout">server.settimeout</a>, and
<a href="##(server).close">server.close</a>.</p>

<p>Note: The function socket.connect is available and is a shortcut for the
creation of client sockets.</p>

<p>Note: Starting with LuaSocket 2.0, the settimeout method affects the behavior
of connect, causing it to return with an error in case of a timeout. If that
happens, you can still call socket.select with the socket in the sendt table.
The socket will be writable when the connection is established.</p>


		<h3>Parameters</h3>
		<ul>
				<li>
				
<p><code><em> address </em></code>: 
Can be an IP address or a host name.</p>

				</li>
				<li>
				
<p><code><em> port </em></code>: 
Port must be an integer number in the range [1..64K).</p>


				</li>
		</ul>
</dd>
</dl>
		<dl class="function">
<dt>

<a id="#(master).getsockname" >
<strong>master:getsockname()</strong>
</a>
</dt>
<dd>
	
<p>As in <a href="##(server).getsockname">server.getsockname</a>.</p>


</dd>
</dl>
		<dl class="function">
<dt>

<a id="#(master).getstats" >
<strong>master:getstats()</strong>
</a>
</dt>
<dd>
	
<p>As in <a href="##(server).getstats">server.getstats</a>.</p>


</dd>
</dl>
		<dl class="function">
<dt>

<a id="#(master).listen" >
<strong>master:listen(backlog)</strong>
</a>
</dt>
<dd>
	
<p>Specifies the socket is willing to receive connections, transforming the object into a server object.</p>

	

<p>Server objects support the <a href="##(server).accept">server.accept</a>, <a href="##(server).getsockname">server.getsockname</a>,
<a href="server.setoption.html">server.setoption</a>, <a href="##(server).settimeout">server.settimeout</a>, and <a href="##(server).close">server.close</a> methods.</p>


		<h3>Parameter</h3>
		<ul>
				<li>
				
<p><code><em> backlog </em></code>: 
Specifies the number of client connections that can be queued waiting for service.
If the queue is full and another client attempts connection, the connection is refused.</p>

				</li>
		</ul>
		<h3>Return values</h3>
			<ol>
				<li>
				
<p><em>#number:</em>
1, in case of success.</p>

				</li>
				<li>
				
<p><em>#nil, #string:</em>
In error cases, error string is provided.</p>


				</li>
			</ol>
</dd>
</dl>
		<dl class="function">
<dt>

<a id="#(master).setstats" >
<strong>master:setstats(received, sent, age)</strong>
</a>
</dt>
<dd>
	
<p>As in <a href="##(server).setstats">server.setstats</a>.</p>


		<h3>Parameters</h3>
		<ul>
				<li>
				
<p><code><em>#number received </em></code>: </p>

				</li>
				<li>
				
<p><code><em>#number sent </em></code>: </p>

				</li>
				<li>
				
<p><code><em>#number age </em></code>: </p>

				</li>
		</ul>
</dd>
</dl>
		<dl class="function">
<dt>

<a id="#(master).settimeout" >
<strong>master:settimeout(value, mode)</strong>
</a>
</dt>
<dd>
	
<p>As in <a href="##(server).settimeout">server.settimeout</a>.</p>


		<h3>Parameters</h3>
		<ul>
				<li>
				
<p><code><em>#number value </em></code>: </p>

				</li>
				<li>
				
<p><code><em>#string mode </em></code>: </p>

				</li>
		</ul>
</dd>
</dl>

			<h2><a id="#(server)" >Type <code>server</code></a></h2>
				
<p>A TCP Server object.</p>

	<h3>Field(s)</h3>
		<dl class="function">
<dt>

<a id="#(server).accept" >
<strong>server:accept()</strong>
</a>
</dt>
<dd>
	
<p>Waits for a remote connection on the server object and returns a <a href="##(client)">#client</a> object representing that connection.</p>

	
<p>Note: calling <a href="##(socket).select">socket.select</a> with a <a href="##(server)">#server</a> object in the recvt parameter before a call to accept does not guarantee accept will return immediately.
Use the <a href="##(socket).settimeout">socket.settimeout</a> method or <em>accept</em> might block until <em>another</em> client shows up.</p>


		<h3>Return values</h3>
			<ol>
				<li>
				
<p><em><a href="##(client)">#client</a>:</em>
 If a connection is successfully initiated.</p>

				</li>
				<li>
				
<p><em>#nil, #string:</em>
 Given error string can be:</p>

<ul>
    <li><strong>'timeout'</strong>: If a timeout condition is met.</li>
    <li>Message describing error, for other errors.</li>
</ul>


				</li>
			</ol>
</dd>
</dl>
		<dl class="function">
<dt>

<a id="#(server).close" >
<strong>server:close()</strong>
</a>
</dt>
<dd>
	
<p>Closes a TCP object.</p>

	

<p>The internal socket used by the object is closed and the local address to which
the object was bound is made available to other applications. No further
operations (except for further calls to the close method) are allowed on a
closed socket.</p>

<p>Note: It is important to close all used sockets once they are not needed,
since, in many systems, each socket uses a file descriptor, which are limited
system resources. Garbage-collected objects are automatically closed before
destruction, though.</p>

</dd>
</dl>
		<dl class="function">
<dt>

<a id="#(server).getsockname" >
<strong>server:getsockname()</strong>
</a>
</dt>
<dd>
	
<p>Returns the local address information associated to the object.</p>


		<h3>Return values</h3>
			<ol>
				<li>
				
<p><em>#string:</em>
Local IP address and a number with the port.</p>

				</li>
				<li>
				
<p><em>#nil:</em>
In case of error.</p>


				</li>
			</ol>
</dd>
</dl>
		<dl class="function">
<dt>

<a id="#(server).getstats" >
<strong>server:getstats()</strong>
</a>
</dt>
<dd>
	
<p>Returns accounting information on the socket, useful for throttling of bandwidth.</p>


		<h3>Return value</h3>
				
<p><em>#number, #number, #number:</em>
The <em>number</em> of bytes received, the <em>number</em>
of bytes sent, and the <em>age of the socket</em> object in seconds.</p>


</dd>
</dl>
		<dl class="function">
<dt>

<a id="#(server).setoption" >
<strong>server:setoption(option, value)</strong>
</a>
</dt>
<dd>
	
<p>Sets options for the TCP object.</p>

	

<p>Options are only needed by low-level or time-critical applications. You should
only modify an option if you are sure you need it.</p>

<p>Note: The given descriptions come from the man pages.</p>


		<h3>Parameters</h3>
		<ul>
				<li>
				
<p><code><em>#string option </em></code>: 
The option name:</p>

<ul>
    <li><strong>'keepalive'</strong>: Setting this option to true enables the periodic
    transmission of messages on a connected socket. Should the connected party
    fail to respond to these messages, the connection is considered broken and
    processes using the socket are notified;</li>
    <li><strong>'linger'</strong>: Controls the action taken when unsent data are queued on a
    socket and a close is performed. The value is a table with a boolean entry 'on'
    and a numeric entry for the time interval 'timeout' in seconds. If the 'on'
    field is set to true, the system will block the process on the close attempt
    until it is able to transmit the data or until 'timeout' has passed. If 'on'
    is false and a close is issued, the system will process the close in a manner
    that allows the process to continue as quickly as possible. I do not advise
    you to set this to anything other than zero;</li>
    <li><strong>'reuseaddr'</strong>: Setting this option indicates that the rules used in
    validating addresses supplied in a call to bind should allow reuse of local
    addresses;</li>
    <li><strong>'tcp-nodelay'</strong>: Setting this option to true disables the Nagle's algorithm
    for the connection.</li>
</ul>

				</li>
				<li>
				
<p><code><em> value </em></code>: 
Depends on the option being set. </p>

				</li>
		</ul>
		<h3>Return values</h3>
			<ol>
				<li>
				
<p><em>#number:</em>
1 in case of success.</p>

				</li>
				<li>
				
<p><em>#nil:</em>
Otherwise.</p>


				</li>
			</ol>
</dd>
</dl>
		<dl class="function">
<dt>

<a id="#(server).setstats" >
<strong>server:setstats(received, sent, age)</strong>
</a>
</dt>
<dd>
	
<p>Resets accounting information on the socket, useful for throttling of bandwidth.</p>


		<h3>Parameters</h3>
		<ul>
				<li>
				
<p><code><em>#number received </em></code>: 
Number with the new number of bytes received.</p>

				</li>
				<li>
				
<p><code><em>#number sent </em></code>: 
Number with the new number of bytes sent.</p>

				</li>
				<li>
				
<p><code><em>#number age </em></code>: 
is the new age in seconds.</p>

				</li>
		</ul>
		<h3>Return values</h3>
			<ol>
				<li>
				
<p><em>#number:</em>
1 in case of success.</p>

				</li>
				<li>
				
<p><em>#nil:</em>
Otherwise.</p>


				</li>
			</ol>
</dd>
</dl>
		<dl class="function">
<dt>

<a id="#(server).settimeout" >
<strong>server:settimeout(value, mode)</strong>
</a>
</dt>
<dd>
	
<p>Changes the timeout values for the object.</p>

	

<p>By default, all I/O operations are blocking. That is, any call to the methods
<a href="##(client).send">client.send</a>, <a href="##(client).receive">client.receive</a>, and <a href="##(server).accept">server.accept</a> will block
indefinitely, until the operation completes. The <em>settimeout</em> method defines a
limit on the amount of time the I/O methods can block. When a timeout is set
and the specified amount of time has elapsed, the affected methods give up and
fail with an error code.</p>

<p>Note: although timeout values have millisecond precision in LuaSocket, large
 blocks can cause I/O functions not to respect timeout values due to the time
 the library takes to transfer blocks to and from the OS and to and from the
 Lua interpreter. Also, function that accept host names and perform automatic
 name resolution might be blocked by the resolver for longer than the specified
 timeout value.</p>

<p>Note: The old timeout method is deprecated. The name has been changed for sake
 of uniformity, since all other method names already contained verbs making
 their imperative nature obvious.</p>


		<h3>Parameters</h3>
		<ul>
				<li>
				
<p><code><em>#number value </em></code>: 
The amount of time to wait is specified, in seconds.
The <em>#nil</em> timeout value allows operations to block indefinitely. Negative
timeout values have the same effect.</p>

				</li>
				<li>
				
<p><code><em>#string mode </em></code>: 
There are two timeout modes and both can be used together
 for fine tuning:</p>

<ul>
    <li><strong>'b'</strong>: block timeout. Specifies the upper limit on the amount of time
    LuaSocket can be blocked by the operating system while waiting for completion
    of any single I/O operation. This is the default mode;</li>
    <li><strong>'t'</strong>: total timeout. Specifies the upper limit on the amount of time
    LuaSocket can block a Lua script before returning from a call.</li>
</ul>


				</li>
		</ul>
</dd>
</dl>

			<h2><a id="#(unconnected)" >Type <code>unconnected</code></a></h2>
				
<p>A unconnected UDP object.</p>


	<h3>Field(s)</h3>
		<dl class="function">
<dt>

<a id="#(unconnected).close" >
<strong>unconnected:close()</strong>
</a>
</dt>
<dd>
	
<p>Closes a UDP object.</p>

	

<p>The internal socket used by the object is closed and the local address to which
the object was bound is made available to other applications. No further
operations (except for further calls to the close method) are allowed on a
closed socket.</p>

<p>Note: It is important to close all used sockets once they are not needed, since
, in many systems, each socket uses a file descriptor, which are limited system
resources. Garbage-collected objects are automatically closed before
destruction, though.</p>


</dd>
</dl>
		<dl class="function">
<dt>

<a id="#(unconnected).getsockname" >
<strong>unconnected:getsockname()</strong>
</a>
</dt>
<dd>
	
<p>Returns the local address information associated to the object.</p>

	

<p>Note: UDP sockets are not bound to any address until the
<a href="##(unconnected).setsockname">unconnected.setsockname</a> or the <a href="##(unconnected).sendto">unconnected.sendto</a> method is called for
the first time (in which case it is bound to an ephemeral port and the
wild-card address).</p>


		<h3>Return values</h3>
			<ol>
				<li>
				
<p><em>#string:</em>
With local IP address and a number with the port.</p>

				</li>
				<li>
				
<p><em>#nil:</em>
In case of error.</p>


				</li>
			</ol>
</dd>
</dl>
		<dl class="function">
<dt>

<a id="#(unconnected).receive" >
<strong>unconnected:receive(size)</strong>
</a>
</dt>
<dd>
	
<p>Receives a datagram from the UDP object.</p>

	

<p>If the UDP object is connected, only datagrams coming from the peer are
accepted. Otherwise, the returned datagram can come from any host.</p>


		<h3>Parameter</h3>
		<ul>
				<li>
				
<p><code><em>#number size </em></code>: 
optional Specifies the maximum size of the datagram to be
 retrieved. If there are more than size bytes available in the datagram, the
 excess bytes are discarded. If there are less then size bytes available in the
 current datagram, the available bytes are returned. If size is omitted,
 the maximum datagram size is used (which is currently limited by the
 implementation to 8192 bytes).</p>

				</li>
		</ul>
		<h3>Return values</h3>
			<ol>
				<li>
				

<p>The received datagram, in case of success.</p>

				</li>
				<li>
				
<p><em>#nil, #string:</em>
<em>#nil</em> followed by the string <strong>'timeout'</strong>, in case of
 timeout.</p>


				</li>
			</ol>
</dd>
</dl>
		<dl class="function">
<dt>

<a id="#(unconnected).receivefrom" >
<strong>unconnected:receivefrom(size)</strong>
</a>
</dt>
<dd>
	
<p>Works exactly as the <a href="##(unconnected).receive">unconnected.receive</a> method, except it returns the IP
address and port as extra return values (and is therefore slightly less
efficient).</p>


		<h3>Parameter</h3>
		<ul>
				<li>
				
<p><code><em>#number size </em></code>: </p>

				</li>
		</ul>
		<h3>Return value</h3>
				

<p>address, port</p>


</dd>
</dl>
		<dl class="function">
<dt>

<a id="#(unconnected).sendto" >
<strong>unconnected:sendto(datagram, ip, port)</strong>
</a>
</dt>
<dd>
	
<p>Sends a datagram to the specified IP address and port number.</p>

	

<p>Note: In UDP, the send method never blocks and the only way it can fail is if
the underlying transport layer refuses to send a message to the specified
address (i.e. no interface accepts the address).</p>


		<h3>Parameters</h3>
		<ul>
				<li>
				
<p><code><em> datagram </em></code>: 
A _#string" with the datagram contents. The maximum datagram
 size for UDP is 64K minus IP layer overhead. However datagrams larger than the
 link layer packet size will be fragmented, which may deteriorate performance
 and/or reliability.</p>

				</li>
				<li>
				
<p><code><em> ip </em></code>: 
The IP address of the recipient. Host names are not allowed for
 performance reasons. </p>

				</li>
				<li>
				
<p><code><em> port </em></code>: 
The port number at the recipient.</p>

				</li>
		</ul>
		<h3>Return values</h3>
			<ol>
				<li>
				
<p><em>#number:</em>
1, in case of success.</p>

				</li>
				<li>
				
<p><em>#nil, #string:</em>
In error cases, error string is provided.</p>


				</li>
			</ol>
</dd>
</dl>
		<dl class="function">
<dt>

<a id="#(unconnected).setoption" >
<strong>unconnected.setoption(option, value)</strong>
</a>
</dt>
<dd>
	
<p>Sets options for the UDP object.</p>

	

<p>Options are only needed by low-level or time-critical applications. You should
only modify an option if you are sure you need it.</p>

<p>Note: The descriptions above come from the man pages.</p>


		<h3>Parameters</h3>
		<ul>
				<li>
				
<p><code><em>#string option </em></code>: 
The option name:</p>

<ul>
    <li><strong>'dontroute'</strong>: Setting this option to true indicates that outgoing messages
    should bypass the standard routing facilities;</li>
    <li><strong>'broadcast'</strong>: Setting this option to true requests permission to send
    broadcast datagrams on the socket.</li>
</ul>

				</li>
				<li>
				
<p><code><em> value </em></code>: 
Depends on the option being set.</p>

				</li>
		</ul>
		<h3>Return values</h3>
			<ol>
				<li>
				
<p><em>#number:</em>
1, in case of success.</p>

				</li>
				<li>
				
<p><em>#nil, #string:</em>
In error cases, error string is provided.</p>


				</li>
			</ol>
</dd>
</dl>
		<dl class="function">
<dt>

<a id="#(unconnected).setpeername" >
<strong>unconnected:setpeername(address, port)</strong>
</a>
</dt>
<dd>
	
<p>As in <a href="##(connected).setpeername">connected.setpeername</a>.</p>


		<h3>Parameters</h3>
		<ul>
				<li>
				
<p><code><em>#string address </em></code>: </p>

				</li>
				<li>
				
<p><code><em>#number port </em></code>: </p>

				</li>
		</ul>
</dd>
</dl>
		<dl class="function">
<dt>

<a id="#(unconnected).setsockname" >
<strong>unconnected:setsockname(address, port)</strong>
</a>
</dt>
<dd>
	
<p>Binds the UDP object to a local address.</p>

	

<p>Note: This method can only be called before any datagram is sent through the
UDP object, and only once. Otherwise, the system automatically binds the object
to all local interfaces and chooses an ephemeral port as soon as the first
datagram is sent. After the local address is set, either automatically by the
system or explicitly by setsockname, it cannot be changed.</p>


		<h3>Parameters</h3>
		<ul>
				<li>
				
<p><code><em> address </em></code>: 
Can be an IP address or a host name. If address is <strong>'*'</strong> the
 system binds to all local interfaces using the constant INADDR_ANY.</p>

				</li>
				<li>
				
<p><code><em>#number port </em></code>: 
If port is <strong>0</strong>, the system chooses an ephemeral port.</p>

				</li>
		</ul>
		<h3>Return value</h3>
				
<p><em>#nil, #string:</em>
In error cases, error string is provided.</p>


</dd>
</dl>
		<dl class="function">
<dt>

<a id="#(unconnected).settimeout" >
<strong>unconnected:settimeout(value)</strong>
</a>
</dt>
<dd>
	
<p>Changes the timeout values for the object.</p>

	

<p>By default, the <a href="##(unconnected).receive">unconnected.receive</a> and <a href="##(unconnected).receivefrom">unconnected.receivefrom</a>
operations are blocking. That is, any call to the methods will block
indefinitely, until data arrives. The <em>settimeout</em> function defines a limit on
the amount of time the functions can block. When a timeout is set and the
specified amount of time has elapsed, the affected methods give up and fail
with an error code.</p>

<p>Note: In UDP, the <a href="##(connected).send">connected.send</a> and <a href="##(unconnected).sendto">unconnected.sendto</a> methods never
block (the datagram is just passed to the OS and the call returns immediately).
Therefore, the <em>settimeout</em> method has no effect on them.</p>

<p>Note: The old <em>timeout</em> method is deprecated. The name has been changed for
sake of uniformity, since all other method names already contained verbs making
their imperative nature obvious.</p>


		<h3>Parameter</h3>
		<ul>
				<li>
				
<p><code><em>#number value </em></code>: 
The amount of time to wait, in seconds. The <em>#nil</em> timeout
 value allows operations to block indefinitely. Negative timeout values have
 the same effect.</p>


				</li>
		</ul>
</dd>
</dl>

</div>

</div>
</body>
</html>
