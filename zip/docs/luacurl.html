<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html>
	<head>
		<link rel="stylesheet" href="stylesheet.css" type="text/css"/>
	</head>
<body>
<div id="container">
<div id="product">
	<div id="product_logo"></div>
	<div id="product_name"><big><b></b></big></div>
	<div id="product_description"></div>
</div>
<div id="main">
	<div id="navigation">
		<h2>Modules</h2>
			<ul><li>
				<a href="index.html">index</a>
			</li></ul>
		<ul>
					<li><a href="base64.html">base64</a></li>
					<li><a href="bit.html">bit</a></li>
					<li><a href="coroutine.html">coroutine</a></li>
					<li><a href="debug.html">debug</a></li>
					<li><a href="des56.html">des56</a></li>
					<li><a href="ex.html">ex</a></li>
					<li><a href="global.html">global</a></li>
					<li><a href="io.html">io</a></li>
					<li><a href="lfs.html">lfs</a></li>
					<li><a href="ltn12.html">ltn12</a></li>
					<li>luacurl</li>
					<li><a href="luasql.html">luasql</a></li>
					<li><a href="math.html">math</a></li>
					<li><a href="md5.html">md5</a></li>
					<li><a href="mime.html">mime</a></li>
					<li><a href="os.html">os</a></li>
					<li><a href="package.html">package</a></li>
					<li><a href="socket.html">socket</a></li>
					<li><a href="socket.ftp.html">socket.ftp</a></li>
					<li><a href="socket.http.html">socket.http</a></li>
					<li><a href="socket.smtp.html">socket.smtp</a></li>
					<li><a href="socket.url.html">socket.url</a></li>
					<li><a href="string.html">string</a></li>
					<li><a href="table.html">table</a></li>
					<li><a href="wx.html">wx</a></li>
					<li><a href="wxaui.html">wxaui</a></li>
					<li><a href="wxlua.html">wxlua</a></li>
					<li><a href="wxstc.html">wxstc</a></li>
		</ul>
	</div>
	<div id="content">
   <h1>Module <code>luacurl</code></h1>
   
<p>LuaCURL is a module providing Internet browsing capabilities based on the CURL library.</p>

   
<p>The module interface follows strictly the CURl architecture and is very
easy to use if the programmer has already experience with CURL. The only
LuaCURL luaopen_luacurl public function register itself to the Lua context
defining a namespace curl with one constructor and some utility functions.
<em>COMENT OF THE DOCUMENTOR:</em>  Its just not well documented... so I played
around with it. I just can't say if this all is right, but luacurl is
awful to use! I even appreciate luasocket for this stuff. "(-.-)
I also would appreciate somebody who can tell me how to use it correctly to
document it correctly</p>

			<h2>Usages:</h2>
		<ul>
			<li><pre class="example"><code>require("luacurl")</code></pre></li>
			<li><pre class="example"><code>local curl = require("luacurl")
</code></pre></li>
		</ul>

			<h2><a id="#(curl)">Type <code>curl</code></a></h2>
				<table class="function_list">
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).ABORTED_BY_CALLBACK">curl.ABORTED_BY_CALLBACK</a></td>
		<td class="summary">
<p>Its a selfdescribing error...</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).ARRAY">curl.ARRAY</a></td>
		<td class="summary">
<p>Another possibility to send options is the <a href="##(curl).ARRAY">curl.ARRAY</a> option, that
passes a #table of valid options.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).AUTH_ANY">curl.AUTH_ANY</a></td>
		<td class="summary">
<p>This is a convenience macro that sets all bits and thus makes libcurl pick any it finds suitable.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).AUTH_ANYSAFE">curl.AUTH_ANYSAFE</a></td>
		<td class="summary">
<p>This is a convenience macro that sets all bits except Basic and thus makes
libcurl pick any it finds suitable.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).AUTH_BASIC">curl.AUTH_BASIC</a></td>
		<td class="summary">
<p>HTTP Basic authentication.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).AUTH_DIGEST">curl.AUTH_DIGEST</a></td>
		<td class="summary">
<p>HTTP Digest authentication.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).AUTH_GSSNEGOTIATE">curl.AUTH_GSSNEGOTIATE</a></td>
		<td class="summary">
<p>HTTP GSS-Negotiate authentication.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).AUTH_NONE">curl.AUTH_NONE</a></td>
		<td class="summary">
<p>No HTTP authentication.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).AUTH_NTLM">curl.AUTH_NTLM</a></td>
		<td class="summary">
<p>HTTP NTLM authentication.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).BAD_CALLING_ORDER">curl.BAD_CALLING_ORDER</a></td>
		<td class="summary">
<p>Its a selfdescribing error...</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).BAD_CONTENT_ENCODING">curl.BAD_CONTENT_ENCODING</a></td>
		<td class="summary">
<p>Its a selfdescribing error...</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).BAD_DOWNLOAD_RESUME">curl.BAD_DOWNLOAD_RESUME</a></td>
		<td class="summary">
<p>Its a selfdescribing error...</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).BAD_FUNCTION_ARGUMENT">curl.BAD_FUNCTION_ARGUMENT</a></td>
		<td class="summary">
<p>Its a selfdescribing error...</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).BAD_PASSWORD_ENTERED">curl.BAD_PASSWORD_ENTERED</a></td>
		<td class="summary">
<p>Its a selfdescribing error...</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).BUFFER">curl.BUFFER</a></td>
		<td class="summary">
<p>It tells libcurl that the file contents are already present in a buffer.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).BUFFERLENGTH">curl.BUFFERLENGTH</a></td>
		<td class="summary">
<p>The parameter is a #number which gives the length of the buffer.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).BUFFERPTR">curl.BUFFERPTR</a></td>
		<td class="summary">
<p>The parameter is a (pointer) to the buffer to be uploaded.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).CLOSEPOLICY_CALLBACK">curl.CLOSEPOLICY_CALLBACK</a></td>
		<td class="summary">
<p><em>(obsolete)</em> The callback of <a href="##(curl).OPT_CLOSEPOLICY">curl.OPT_CLOSEPOLICY</a> <br />
Used for <a href="##(curl).OPT_CLOSEPOLICY">curl.OPT_CLOSEPOLICY</a></p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).CLOSEPOLICY_LEAST_RECENTLY_USED">curl.CLOSEPOLICY_LEAST_RECENTLY_USED</a></td>
		<td class="summary">
<p><em>(obsolete)</em> The least recently used close-policy <br />
Used for <a href="##(curl).OPT_CLOSEPOLICY">curl.OPT_CLOSEPOLICY</a></p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).CLOSEPOLICY_LEAST_TRAFFIC">curl.CLOSEPOLICY_LEAST_TRAFFIC</a></td>
		<td class="summary">
<p><em>(obsolete)</em> The least traffic using close-policy <br />
Used for <a href="##(curl).OPT_CLOSEPOLICY">curl.OPT_CLOSEPOLICY</a></p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).CLOSEPOLICY_OLDEST">curl.CLOSEPOLICY_OLDEST</a></td>
		<td class="summary">
<p><em>(obsolete)</em> The oldest close-policy <br />
Used for <a href="##(curl).OPT_CLOSEPOLICY">curl.OPT_CLOSEPOLICY</a></p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).CLOSEPOLICY_SLOWEST">curl.CLOSEPOLICY_SLOWEST</a></td>
		<td class="summary">
<p><em>(obsolete)</em> The slowest close-policy <br />
Used for <a href="##(curl).OPT_CLOSEPOLICY">curl.OPT_CLOSEPOLICY</a></p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).CONTENTHEADER">curl.CONTENTHEADER</a></td>
		<td class="summary">
<p>Specifies extra headers for the form POST section.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).CONTENTSLENGTH">curl.CONTENTSLENGTH</a></td>
		<td class="summary">
<p>The length of the contents.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).CONTENTTYPE">curl.CONTENTTYPE</a></td>
		<td class="summary">
<p>The #string which provides the content-type for this part, possibly instead
of an internally chosen one.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).COPYCONTENTS">curl.COPYCONTENTS</a></td>
		<td class="summary">
<p>The actual data to send away.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).COPYNAME">curl.COPYNAME</a></td>
		<td class="summary">
<p>The #string provides the copy-name.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).COULDNT_CONNECT">curl.COULDNT_CONNECT</a></td>
		<td class="summary">
<p>Its a selfdescribing error...</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).COULDNT_RESOLVE_HOST">curl.COULDNT_RESOLVE_HOST</a></td>
		<td class="summary">
<p>Its a selfdescribing error...</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).COULDNT_RESOLVE_PROXY">curl.COULDNT_RESOLVE_PROXY</a></td>
		<td class="summary">
<p>Its a selfdescribing error...</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).CURL_FORMADD_DISABLED">curl.CURL_FORMADD_DISABLED</a></td>
		<td class="summary">
<p>UNDOCUMENTED/NOTHING FOUND</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).CURL_FORMADD_ILLEGAL_ARRAY">curl.CURL_FORMADD_ILLEGAL_ARRAY</a></td>
		<td class="summary">
<p>UNDOCUMENTED/NOTHING FOUND</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).CURL_FORMADD_INCOMPLETE">curl.CURL_FORMADD_INCOMPLETE</a></td>
		<td class="summary">
<p>UNDOCUMENTED/NOTHING FOUND</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).CURL_FORMADD_MEMORY">curl.CURL_FORMADD_MEMORY</a></td>
		<td class="summary">
<p>UNDOCUMENTED/NOTHING FOUND</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).CURL_FORMADD_NULL">curl.CURL_FORMADD_NULL</a></td>
		<td class="summary">
<p>UNDOCUMENTED/NOTHING FOUND</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).CURL_FORMADD_OK">curl.CURL_FORMADD_OK</a></td>
		<td class="summary">
<p>UNDOCUMENTED/NOTHING FOUND</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).CURL_FORMADD_OPTION_TWICE">curl.CURL_FORMADD_OPTION_TWICE</a></td>
		<td class="summary">
<p>UNDOCUMENTED/NOTHING FOUND</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).CURL_FORMADD_UNKNOWN_OPTION">curl.CURL_FORMADD_UNKNOWN_OPTION</a></td>
		<td class="summary">
<p>UNDOCUMENTED/NOTHING FOUND</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).END">curl.END</a></td>
		<td class="summary">
<p>Put this at the end of the #table passed to <a href="curl.ARRAY.html">curl.ARRAY</a>.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).FAILED_INIT">curl.FAILED_INIT</a></td>
		<td class="summary">
<p>Its a selfdescribing error...</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).FILE">curl.FILE</a></td>
		<td class="summary">
<p>Makes this part a file upload part.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).FILECONTENT">curl.FILECONTENT</a></td>
		<td class="summary">
<p>Causes that file to be read and its contents used as data in this part.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).FILENAME">curl.FILENAME</a></td>
		<td class="summary">
<p>The #string tells libcurl to use the given string as the filename in the
file upload part instead of the actual file name.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).FILESIZE_EXCEEDED">curl.FILESIZE_EXCEEDED</a></td>
		<td class="summary">
<p>Its a selfdescribing error...</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).FILE_COULDNT_READ_FILE">curl.FILE_COULDNT_READ_FILE</a></td>
		<td class="summary">
<p>Its a selfdescribing error...</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).FTPAUTH_DEFAULT">curl.FTPAUTH_DEFAULT</a></td>
		<td class="summary">
<p>Allow libcurl to decide.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).FTPAUTH_SSL">curl.FTPAUTH_SSL</a></td>
		<td class="summary">
<p>Try "AUTH SSL" first, and only if that fails try "AUTH TLS".</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).FTPAUTH_TLS">curl.FTPAUTH_TLS</a></td>
		<td class="summary">
<p>Try "AUTH TLS" first, and only if that fails try "AUTH SSL".</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).FTPSSL_ALL">curl.FTPSSL_ALL</a></td>
		<td class="summary">
<p>Require SSL for all communication.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).FTPSSL_CONTROL">curl.FTPSSL_CONTROL</a></td>
		<td class="summary">
<p>Require SSL for the control connection.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).FTPSSL_NONE">curl.FTPSSL_NONE</a></td>
		<td class="summary">
<p>Don't attempt to use SSL.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).FTPSSL_TRY">curl.FTPSSL_TRY</a></td>
		<td class="summary">
<p>Try using SSL, proceed as normal otherwise.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).FTP_ACCESS_DENIED">curl.FTP_ACCESS_DENIED</a></td>
		<td class="summary">
<p>Its a selfdescribing error...</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).FTP_CANT_GET_HOST">curl.FTP_CANT_GET_HOST</a></td>
		<td class="summary">
<p>Its a selfdescribing error...</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).FTP_CANT_RECONNECT">curl.FTP_CANT_RECONNECT</a></td>
		<td class="summary">
<p>Its a selfdescribing error...</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).FTP_COULDNT_GET_SIZE">curl.FTP_COULDNT_GET_SIZE</a></td>
		<td class="summary">
<p>Its a selfdescribing error...</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).FTP_COULDNT_RETR_FILE">curl.FTP_COULDNT_RETR_FILE</a></td>
		<td class="summary">
<p>Its a selfdescribing error...</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).FTP_COULDNT_SET_ASCII">curl.FTP_COULDNT_SET_ASCII</a></td>
		<td class="summary">
<p>Its a selfdescribing error...</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).FTP_COULDNT_SET_BINARY">curl.FTP_COULDNT_SET_BINARY</a></td>
		<td class="summary">
<p>Its a selfdescribing error...</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).FTP_COULDNT_STOR_FILE">curl.FTP_COULDNT_STOR_FILE</a></td>
		<td class="summary">
<p>Its a selfdescribing error...</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).FTP_COULDNT_USE_REST">curl.FTP_COULDNT_USE_REST</a></td>
		<td class="summary">
<p>Its a selfdescribing error...</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).FTP_PORT_FAILED">curl.FTP_PORT_FAILED</a></td>
		<td class="summary">
<p>Its a selfdescribing error...</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).FTP_QUOTE_ERROR">curl.FTP_QUOTE_ERROR</a></td>
		<td class="summary">
<p>Its a selfdescribing error...</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).FTP_SSL_FAILED">curl.FTP_SSL_FAILED</a></td>
		<td class="summary">
<p>Its a selfdescribing error...</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).FTP_USER_PASSWORD_INCORRECT">curl.FTP_USER_PASSWORD_INCORRECT</a></td>
		<td class="summary">
<p>Its a selfdescribing error...</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).FTP_WEIRD_227_FORMAT">curl.FTP_WEIRD_227_FORMAT</a></td>
		<td class="summary">
<p>Its a selfdescribing error...</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).FTP_WEIRD_PASS_REPLY">curl.FTP_WEIRD_PASS_REPLY</a></td>
		<td class="summary">
<p>Its a selfdescribing error...</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).FTP_WEIRD_PASV_REPLY">curl.FTP_WEIRD_PASV_REPLY</a></td>
		<td class="summary">
<p>Its a selfdescribing error...</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).FTP_WEIRD_SERVER_REPLY">curl.FTP_WEIRD_SERVER_REPLY</a></td>
		<td class="summary">
<p>Its a selfdescribing error...</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).FTP_WEIRD_USER_REPLY">curl.FTP_WEIRD_USER_REPLY</a></td>
		<td class="summary">
<p>Its a selfdescribing error...</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).FTP_WRITE_ERROR">curl.FTP_WRITE_ERROR</a></td>
		<td class="summary">
<p>Its a selfdescribing error...</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).FUNCTION_NOT_FOUND">curl.FUNCTION_NOT_FOUND</a></td>
		<td class="summary">
<p>Its a selfdescribing error...</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).GOT_NOTHING">curl.GOT_NOTHING</a></td>
		<td class="summary">
<p>Its a selfdescribing error...</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).HTTP_POST_ERROR">curl.HTTP_POST_ERROR</a></td>
		<td class="summary">
<p>Its a selfdescribing error...</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).HTTP_RANGE_ERROR">curl.HTTP_RANGE_ERROR</a></td>
		<td class="summary">
<p>Its a selfdescribing error...</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).HTTP_RETURNED_ERROR">curl.HTTP_RETURNED_ERROR</a></td>
		<td class="summary">
<p>Its a selfdescribing error...</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).HTTP_VERSION_1_0">curl.HTTP_VERSION_1_0</a></td>
		<td class="summary">
<p>Enforce HTTP 1.0 requests.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).HTTP_VERSION_1_1">curl.HTTP_VERSION_1_1</a></td>
		<td class="summary">
<p>Enforce HTTP 1.1 requests.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).HTTP_VERSION_NONE">curl.HTTP_VERSION_NONE</a></td>
		<td class="summary">
<p>We don't care about what version the library uses.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).INFO_CONNECT_TIME">curl.INFO_CONNECT_TIME</a></td>
		<td class="summary">
<p>The time, in seconds, it took from the start until the connect to the remote host (or proxy) was completed.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).INFO_CONTENT_LENGTH_DOWNLOAD">curl.INFO_CONTENT_LENGTH_DOWNLOAD</a></td>
		<td class="summary">
<p>The content-length of the download.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).INFO_CONTENT_LENGTH_UPLOAD">curl.INFO_CONTENT_LENGTH_UPLOAD</a></td>
		<td class="summary">
<p>The specified size of the upload.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).INFO_CONTENT_TYPE">curl.INFO_CONTENT_TYPE</a></td>
		<td class="summary">
<p>The content-type of the downloaded object.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).INFO_COOKIELIST">curl.INFO_COOKIELIST</a></td>
		<td class="summary">
<p>Pass a #table of all cookies cURL knows (expired ones, too).</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).INFO_EFFECTIVE_URL">curl.INFO_EFFECTIVE_URL</a></td>
		<td class="summary">
<p>The last used effective URL.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).INFO_FILETIME">curl.INFO_FILETIME</a></td>
		<td class="summary">
<p>The remote time of the retrieved document
(in number of seconds since 1 Jan 1970 in the GMT/UTC time zone).</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).INFO_HEADER_SIZE">curl.INFO_HEADER_SIZE</a></td>
		<td class="summary">
<p>The total size of all the headers received.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).INFO_HTTPAUTH_AVAIL">curl.INFO_HTTPAUTH_AVAIL</a></td>
		<td class="summary">
<p>Bitmask indicating the authentication method(s) available.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).INFO_HTTP_CONNECTCODE">curl.INFO_HTTP_CONNECTCODE</a></td>
		<td class="summary">
<p>The last received proxy response code to a CONNECT request.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).INFO_LASTSOCKET">curl.INFO_LASTSOCKET</a></td>
		<td class="summary">
<p>The last socket used by this curl session.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).INFO_NAMELOOKUP_TIME">curl.INFO_NAMELOOKUP_TIME</a></td>
		<td class="summary">
<p>The time, in seconds, it took from the start until the name resolving was completed.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).INFO_NONE">curl.INFO_NONE</a></td>
		<td class="summary">

<p><br /> Used as parameter for <a href="##(curlobj).getinfo">curlobj.getinfo</a></p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).INFO_NUM_CONNECTS">curl.INFO_NUM_CONNECTS</a></td>
		<td class="summary">
<p>How many new connections libcurl had to create to achieve the previous
transfer (only the successful connects are counted).</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).INFO_OS_ERRNO">curl.INFO_OS_ERRNO</a></td>
		<td class="summary">
<p>The errno variable from a connect failure.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).INFO_PRETRANSFER_TIME">curl.INFO_PRETRANSFER_TIME</a></td>
		<td class="summary">
<p>The time, in seconds, it took from the start until the file transfer is just about to begin.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).INFO_PRIVATE">curl.INFO_PRIVATE</a></td>
		<td class="summary">
<p>The pointer to the private data associated with the curl handle.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).INFO_PROXYAUTH_AVAIL">curl.INFO_PROXYAUTH_AVAIL</a></td>
		<td class="summary">
<p>Bitmask indicating the authentication method(s) available for your proxy
authentication.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).INFO_REDIRECT_COUNT">curl.INFO_REDIRECT_COUNT</a></td>
		<td class="summary">
<p>The total number of redirections that were actually followed.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).INFO_REDIRECT_TIME">curl.INFO_REDIRECT_TIME</a></td>
		<td class="summary">
<p>The total time, in seconds, it took for all redirection steps include name
lookup, connect, pretransfer and transfer before final transaction was started.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).INFO_REQUEST_SIZE">curl.INFO_REQUEST_SIZE</a></td>
		<td class="summary">
<p>The total size of the issued requests.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).INFO_RESPONSE_CODE">curl.INFO_RESPONSE_CODE</a></td>
		<td class="summary">
<p>The last received HTTP, FTP or SMTP response code.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).INFO_SIZE_DOWNLOAD">curl.INFO_SIZE_DOWNLOAD</a></td>
		<td class="summary">
<p>The total amount of bytes that were downloaded.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).INFO_SIZE_UPLOAD">curl.INFO_SIZE_UPLOAD</a></td>
		<td class="summary">
<p>The total amount of bytes that were uploaded.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).INFO_SPEED_DOWNLOAD">curl.INFO_SPEED_DOWNLOAD</a></td>
		<td class="summary">
<p>The average download speed that curl measured for the complete download.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).INFO_SPEED_UPLOAD">curl.INFO_SPEED_UPLOAD</a></td>
		<td class="summary">
<p>The average upload speed that curl measured for the complete upload.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).INFO_SSL_ENGINES">curl.INFO_SSL_ENGINES</a></td>
		<td class="summary">
<p>Pass a #table of OpenSSL crypto-engines supported.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).INFO_SSL_VERIFYRESULT">curl.INFO_SSL_VERIFYRESULT</a></td>
		<td class="summary">
<p>The result of the certification verification that was requested
(using the <a href="##(curl).OPT_SSL_VERIFYPEER">curl.OPT<em>SSL</em>VERIFYPEER</a> option to <a href="##(curlobj).setopt">curlobj.setopt</a>).</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).INFO_STARTTRANSFER_TIME">curl.INFO_STARTTRANSFER_TIME</a></td>
		<td class="summary">
<p>The time, in seconds, it took from the start until the first byte is received by libcurl.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).INFO_TOTAL_TIME">curl.INFO_TOTAL_TIME</a></td>
		<td class="summary">
<p>The total time in seconds for the previous transfer, including name resolving, TCP connect etc.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).INTERFACE_FAILED">curl.INTERFACE_FAILED</a></td>
		<td class="summary">
<p>Its a selfdescribing error...</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).IOCMD_NOP">curl.IOCMD_NOP</a></td>
		<td class="summary">
<p>UNDOCUMENTED/NOTHING FOUND</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).IOCMD_RESTARTREAD">curl.IOCMD_RESTARTREAD</a></td>
		<td class="summary">
<p>UNDOCUMENTED/NOTHING FOUND</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).IOE_FAILRESTART">curl.IOE_FAILRESTART</a></td>
		<td class="summary">
<p>UNDOCUMENTED/NOTHING FOUND</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).IOE_OK">curl.IOE_OK</a></td>
		<td class="summary">
<p>UNDOCUMENTED/NOTHING FOUND</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).IOE_UNKNOWNCMD">curl.IOE_UNKNOWNCMD</a></td>
		<td class="summary">
<p>UNDOCUMENTED/NOTHING FOUND</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).IPRESOLVE_V4">curl.IPRESOLVE_V4</a></td>
		<td class="summary">
<p>Resolve to IPv4 addresses.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).IPRESOLVE_V6">curl.IPRESOLVE_V6</a></td>
		<td class="summary">
<p>Resolve to IPv6 addresses.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).IPRESOLVE_WHATEVER">curl.IPRESOLVE_WHATEVER</a></td>
		<td class="summary">
<p>Default, resolves addresses to all IP versions that your system allows.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).LDAP_CANNOT_BIND">curl.LDAP_CANNOT_BIND</a></td>
		<td class="summary">
<p>Its a selfdescribing error...</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).LDAP_INVALID_URL">curl.LDAP_INVALID_URL</a></td>
		<td class="summary">
<p>Its a selfdescribing error...</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).LDAP_SEARCH_FAILED">curl.LDAP_SEARCH_FAILED</a></td>
		<td class="summary">
<p>Its a selfdescribing error...</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).LIBRARY_NOT_FOUND">curl.LIBRARY_NOT_FOUND</a></td>
		<td class="summary">
<p>Its a selfdescribing error...</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).LOGIN_DENIED">curl.LOGIN_DENIED</a></td>
		<td class="summary">
<p>Its a selfdescribing error...</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).MALFORMAT_USER">curl.MALFORMAT_USER</a></td>
		<td class="summary">
<p>Its a selfdescribing error...</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).NAMELENGTH">curl.NAMELENGTH</a></td>
		<td class="summary">
<p>UNDOCUMENTED/NOTHING FOUND</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).NETRC_IGNORED">curl.NETRC_IGNORED</a></td>
		<td class="summary">
<p>The library will ignore the file and use only the information in the URL.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).NETRC_OPTIONAL">curl.NETRC_OPTIONAL</a></td>
		<td class="summary">
<p>The use of your ~/.netrc file is optional, and information in the URL is to be preferred.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).NETRC_REQUIRED">curl.NETRC_REQUIRED</a></td>
		<td class="summary">
<p>This value tells the library that use of the file is required, to ignore
the information in the <a href="##(curl).OPT_URL">curl.OPT_URL</a>, and to search the file for the host
only.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).OBSOLETE">curl.OBSOLETE</a></td>
		<td class="summary">
<p>UNDOCUMENTED/NOTHING FOUND</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).OBSOLETE2">curl.OBSOLETE2</a></td>
		<td class="summary">
<p>UNDOCUMENTED/NOTHING FOUND</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).OK">curl.OK</a></td>
		<td class="summary">
<p>Returnd by any <a href="##(curl)">#curl</a> related function to say anything went well.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).OPERATION_TIMEOUTED">curl.OPERATION_TIMEOUTED</a></td>
		<td class="summary">
<p>Its a selfdescribing error...</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).OPT_AUTOREFERER">curl.OPT_AUTOREFERER</a></td>
		<td class="summary">
<p>Pass a #boolean set to true to enable this.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).OPT_BUFFERSIZE">curl.OPT_BUFFERSIZE</a></td>
		<td class="summary">
<p>Pass a #number specifying your preferred size (in bytes) for the receive
buffer in libcurl.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).OPT_CAINFO">curl.OPT_CAINFO</a></td>
		<td class="summary">
<p>Pass a #string naming a file holding one or more certificates to verify the peer with.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).OPT_CAPATH">curl.OPT_CAPATH</a></td>
		<td class="summary">
<p>Pass a #string naming a directory holding multiple CA certificates to verify the peer with.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).OPT_CLOSEPOLICY">curl.OPT_CLOSEPOLICY</a></td>
		<td class="summary">
<p><em>(Obsolete)</em> This option does nothing.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).OPT_CONNECTTIMEOUT">curl.OPT_CONNECTTIMEOUT</a></td>
		<td class="summary">
<p>The #number should contain the maximum time in seconds that you allow the connection to the server to take.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).OPT_COOKIE">curl.OPT_COOKIE</a></td>
		<td class="summary">
<p>It will be used to set a cookie in the http request.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).OPT_COOKIEFILE">curl.OPT_COOKIEFILE</a></td>
		<td class="summary">
<p>The #string should contain the name of your file holding cookie data to read.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).OPT_COOKIEJAR">curl.OPT_COOKIEJAR</a></td>
		<td class="summary">
<p>Pass a file name as #string.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).OPT_COOKIESESSION">curl.OPT_COOKIESESSION</a></td>
		<td class="summary">
<p>Pass a #boolean set to true to mark this as a new cookie "session".</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).OPT_CRLF">curl.OPT_CRLF</a></td>
		<td class="summary">
<p>If the value is set to true, libcurl converts Unix newlines to CRLF newlines on transfers.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).OPT_CUSTOMREQUEST">curl.OPT_CUSTOMREQUEST</a></td>
		<td class="summary">
<p>The #string can be used to specify the request instead of GET or HEAD when
performing HTTP based requests, instead of LIST and NLST when performing
FTP directory listings and instead of LIST and RETR when issuing POP3 based
commands.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).OPT_DNS_CACHE_TIMEOUT">curl.OPT_DNS_CACHE_TIMEOUT</a></td>
		<td class="summary">
<p>This sets the timeout in seconds.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).OPT_DNS_USE_GLOBAL_CACHE">curl.OPT_DNS_USE_GLOBAL_CACHE</a></td>
		<td class="summary">
<p>If the value is true, it tells curl to use a global DNS cache that will
survive between easy handle creations and deletions.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).OPT_EGDSOCKET">curl.OPT_EGDSOCKET</a></td>
		<td class="summary">
<p>Pass a path name to the Entropy Gathering Daemon socket.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).OPT_ENCODING">curl.OPT_ENCODING</a></td>
		<td class="summary">
<p>_It has got an update...</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).OPT_FAILONERROR">curl.OPT_FAILONERROR</a></td>
		<td class="summary">
<p>A parameter set to true tells the library to fail silently if the HTTP code
returned is equal to or larger than 400.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).OPT_FILETIME">curl.OPT_FILETIME</a></td>
		<td class="summary">
<p>If the #boolean is true, libcurl will attempt to get the modification date
of the remote document in this operation.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).OPT_FOLLOWLOCATION">curl.OPT_FOLLOWLOCATION</a></td>
		<td class="summary">
<p>A #boolean set to true tells the library to follow any Location:
header that the server sends as part of a HTTP header.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).OPT_FORBID_REUSE">curl.OPT_FORBID_REUSE</a></td>
		<td class="summary">
<p>Set to ture to make the next transfer explicitly close the connection when done.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).OPT_FRESH_CONNECT">curl.OPT_FRESH_CONNECT</a></td>
		<td class="summary">
<p>Set to true to make the next transfer use a new (fresh) connection by force.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).OPT_FTPAPPEND">curl.OPT_FTPAPPEND</a></td>
		<td class="summary">
<p>A parameter set to true tells the library to append to the remote file instead of overwrite it.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).OPT_FTPLISTONLY">curl.OPT_FTPLISTONLY</a></td>
		<td class="summary">
<p>A parameter set to true tells the library to just list the names of files in
a directory, instead of doing a full directory listing that would include
file sizes, dates etc.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).OPT_FTPPORT">curl.OPT_FTPPORT</a></td>
		<td class="summary">
<p>The #string will be used to get the IP address to use for the FTP PORT instruction.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).OPT_FTPSSLAUTH">curl.OPT_FTPSSLAUTH</a></td>
		<td class="summary">
<p>Pass a #number using one of the values from below, to alter how libcurl
issues "AUTH TLS" or "AUTH SSL" when FTP over SSL is activated .</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).OPT_FTP_ACCOUNT">curl.OPT_FTP_ACCOUNT</a></td>
		<td class="summary">
<p>When an FTP server asks for "account data" after user name and password has
been provided, this data is sent off using the ACCT command.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).OPT_FTP_CREATE_MISSING_DIRS">curl.OPT_FTP_CREATE_MISSING_DIRS</a></td>
		<td class="summary">
<p>If the value is true, curl will attempt to create any remote directory that
it fails to CWD into.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).OPT_FTP_RESPONSE_TIMEOUT">curl.OPT_FTP_RESPONSE_TIMEOUT</a></td>
		<td class="summary">
<p>Causes curl to set a timeout period (in seconds) on the amount of time that
the server is allowed to take in order to generate a response message for a
command before the session is considered hung.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).OPT_FTP_SSL">curl.OPT_FTP_SSL</a></td>
		<td class="summary">
<p>Pass a #number using one of the values from below, to make libcurl use your
desired level of SSL for the transfer.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).OPT_FTP_USE_EPRT">curl.OPT_FTP_USE_EPRT</a></td>
		<td class="summary">
<p>If the value is true, it tells curl to use the EPRT (and LPRT) command when
doing active FTP downloads (which is enabled by <a href="##(curl).OPT_FTPPORT">curl.OPT_FTPPORT</a>).</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).OPT_FTP_USE_EPSV">curl.OPT_FTP_USE_EPSV</a></td>
		<td class="summary">
<p>If the value is true, it tells curl to use the EPSV command when doing
passive FTP downloads (which it always does by default).</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).OPT_HEADER">curl.OPT_HEADER</a></td>
		<td class="summary">
<p>A parameter set to true tells the library to include the header in the body output.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).OPT_HEADERDATA">curl.OPT_HEADERDATA</a></td>
		<td class="summary">
<p>Userparam of <a href="##(curl).OPT_HEADERFUNCTION">curl.OPT_HEADERFUNCTION</a>
<br /> <em>needs:</em> userparam</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).OPT_HEADERFUNCTION">curl.OPT_HEADERFUNCTION</a></td>
		<td class="summary">
<p>This function gets called by libcurl as soon as it has received header data.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).OPT_HTTP200ALIASES">curl.OPT_HTTP200ALIASES</a></td>
		<td class="summary">
<p>List of aliases to be treated as valid HTTP 200 responses.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).OPT_HTTPAUTH">curl.OPT_HTTPAUTH</a></td>
		<td class="summary">
<p>Pass a long as parameter, which is set to a bitmask, to tell libcurl which
authentication method(s) you want it to use.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).OPT_HTTPGET">curl.OPT_HTTPGET</a></td>
		<td class="summary">
<p>If the #boolean is true, this forces the HTTP request to get back to GET.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).OPT_HTTPHEADER">curl.OPT_HTTPHEADER</a></td>
		<td class="summary">
<p>HTTP headers to pass to the server in your HTTP request.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).OPT_HTTPPOST">curl.OPT_HTTPPOST</a></td>
		<td class="summary">
<p>Tells libcurl you want a multipart/formdata HTTP POST to be made and you
instruct what data to pass on to the server.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).OPT_HTTPPROXYTUNNEL">curl.OPT_HTTPPROXYTUNNEL</a></td>
		<td class="summary">
<p>Set the parameter to true to make the library tunnel all operations through
a given HTTP proxy.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).OPT_HTTP_VERSION">curl.OPT_HTTP_VERSION</a></td>
		<td class="summary">
<p>Pass a #number, set to one of the values described below.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).OPT_INFILESIZE">curl.OPT_INFILESIZE</a></td>
		<td class="summary">
<p>When uploading a file to a remote site, this option should be used to tell
libcurl what the expected size of the infile is.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).OPT_INFILESIZE_LARGE">curl.OPT_INFILESIZE_LARGE</a></td>
		<td class="summary">
<p>When uploading a file to a remote site, this option should be used to tell
libcurl what the expected size of the infile is.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).OPT_INTERFACE">curl.OPT_INTERFACE</a></td>
		<td class="summary">
<p>This sets the interface name to use as outgoing network interface.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).OPT_IOCTLDATA">curl.OPT_IOCTLDATA</a></td>
		<td class="summary">
<p>Pass a pointer that will be untouched by libcurl and passed as the 3rd
argument in the ioctl callback set with CURLOPT_IOCTLFUNCTION.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).OPT_IOCTLFUNCTION">curl.OPT_IOCTLFUNCTION</a></td>
		<td class="summary">
<p>This function gets called by libcurl when something special I/O-related
needs to be done that the library can't do by itself.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).OPT_IPRESOLVE">curl.OPT_IPRESOLVE</a></td>
		<td class="summary">
<p>Allows an application to select what kind of IP addresses to use when resolving host names.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).OPT_KRB4LEVEL">curl.OPT_KRB4LEVEL</a></td>
		<td class="summary">
<p>_It has got an update...</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).OPT_LOW_SPEED_LIMIT">curl.OPT_LOW_SPEED_LIMIT</a></td>
		<td class="summary">
<p>The #number contains the transfer speed in bytes per second that the transfer
should be below during <a href="##(curl).OPT_LOW_SPEED_TIME">curl.OPT<em>LOW</em>SPEED_TIME</a> seconds for the library
to consider it too slow and abort.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).OPT_LOW_SPEED_TIME">curl.OPT_LOW_SPEED_TIME</a></td>
		<td class="summary">
<p>The #number contains the time in seconds that the transfer should be below
the <a href="##(curl).OPT_LOW_SPEED_LIMIT">curl.OPT<em>LOW</em>SPEED_LIMIT</a> for the library to consider it too slow and abort.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).OPT_MAXCONNECTS">curl.OPT_MAXCONNECTS</a></td>
		<td class="summary">
<p>The set number will be the persistent connection cache size.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).OPT_MAXFILESIZE">curl.OPT_MAXFILESIZE</a></td>
		<td class="summary">
<p>This allows you to specify the maximum size (in bytes) of a file to download.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).OPT_MAXFILESIZE_LARGE">curl.OPT_MAXFILESIZE_LARGE</a></td>
		<td class="summary">
<p>This allows you to specify the maximum size (in bytes) of a file to download.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).OPT_MAXREDIRS">curl.OPT_MAXREDIRS</a></td>
		<td class="summary">
<p>Pass a #number.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).OPT_NETRC">curl.OPT_NETRC</a></td>
		<td class="summary">
<p>This parameter controls the preference of libcurl between using user names
and passwords from your ~/.netrc file, relative to user names and passwords
in the URL supplied with <a href="##(curl).OPT_URL">curl.OPT_URL</a>.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).OPT_NETRC_FILE">curl.OPT_NETRC_FILE</a></td>
		<td class="summary">
<p>The full path name to the file you want libcurl to use as .netrc file.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).OPT_NOBODY">curl.OPT_NOBODY</a></td>
		<td class="summary">
<p>A #boolean set to true tells the library to not include the body-part in the output.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).OPT_NOPROGRESS">curl.OPT_NOPROGRESS</a></td>
		<td class="summary">
<p>If set to true, it tells the library to shut off the progress
meter completely.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).OPT_NOSIGNAL">curl.OPT_NOSIGNAL</a></td>
		<td class="summary">
<p>If it is true, libcurl will not use any functions that install signal
handlers or any functions that cause signals to be sent to the process.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).OPT_PORT">curl.OPT_PORT</a></td>
		<td class="summary">
<p>Pass a #number specifying what remote port #number to connect to, instead of
the one specified in the <a href="##(curl).OPT_URL">curl.OPT_URL</a> or the default port for the used protocol.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).OPT_POST">curl.OPT_POST</a></td>
		<td class="summary">
<p>A #boolean set to true tells the library to do a regular HTTP post.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).OPT_POSTFIELDS">curl.OPT_POSTFIELDS</a></td>
		<td class="summary">
<p>The full data to post in a HTTP POST operation.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).OPT_POSTFIELDSIZE">curl.OPT_POSTFIELDSIZE</a></td>
		<td class="summary">
<p>If you want to post data to the server without letting libcurl do a strlen()
(C-function, similar to string.len() in Lua) to measure the data size, this
option must be used.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).OPT_POSTFIELDSIZE_LARGE">curl.OPT_POSTFIELDSIZE_LARGE</a></td>
		<td class="summary">
<p>Use this to set the size of the <a href="##(curl).OPT_POSTFIELDS">curl.OPT_POSTFIELDS</a> data to prevent
libcurl from doing strlen() (C-function, similar to string.len() in Lua)
on the data to figure out the size.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).OPT_POSTQUOTE">curl.OPT_POSTQUOTE</a></td>
		<td class="summary">
<p>Pass a list of FTP or SFTP commands to pass to the server after your FTP transfer request.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).OPT_PREQUOTE">curl.OPT_PREQUOTE</a></td>
		<td class="summary">
<p>Pass a list of FTP commands to pass to the server after the transfer type is set.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).OPT_PROGRESSDATA">curl.OPT_PROGRESSDATA</a></td>
		<td class="summary">
<p>userparam of <a href="##(curl).OPT_PROGRESSFUNCTION">curl.OPT_PROGRESSFUNCTION</a>
<br /> <em>needs:</em> userparam</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).OPT_PROGRESSFUNCTION">curl.OPT_PROGRESSFUNCTION</a></td>
		<td class="summary">
<p>This function gets called by libcurl instead of its internal equivalent with
a frequent interval.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).OPT_PROXY">curl.OPT_PROXY</a></td>
		<td class="summary">
<p>IP-address of the proxy.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).OPT_PROXYAUTH">curl.OPT_PROXYAUTH</a></td>
		<td class="summary">
<p>Pass a #number as parameter, which is set to a bitmask, to tell libcurl which
authentication method(s) you want it to use for your proxy authentication.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).OPT_PROXYPORT">curl.OPT_PROXYPORT</a></td>
		<td class="summary">
<p>Set the proxy port to connect to unless it is specified in the proxy #string <a href="##(curl).OPT_PROXY">curl.OPT_PROXY</a>.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).OPT_PROXYTYPE">curl.OPT_PROXYTYPE</a></td>
		<td class="summary">
<p>Available options for this are: <br />
+ <a href="##(curl).PROXY_HTTP">curl.PROXY_HTTP</a> <br />
+ <a href="##(curl).PROXY_HTTP_1_0">curl.PROXY_HTTP<em>1</em>0</a> (added in 7.19.4) <br />
+ <a href="##(curl).PROXY_SOCKS4">curl.PROXY_SOCKS4</a> (added in 7.10) <br />
+ <a href="##(curl).PROXY_SOCKS5">curl.PROXY_SOCKS5</a> <br />
+ <a href="##(curl).PROXY_SOCKS4A">curl.PROXY_SOCKS4A</a> (added in 7.18.0) <br />
+ <a href="##(curl).PROXY_SOCKS5_HOSTNAME">curl.PROXY<em>SOCKS5</em>HOSTNAME</a> (added in 7.18.0) <br />
The HTTP type is default.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).OPT_PROXYUSERPWD">curl.OPT_PROXYUSERPWD</a></td>
		<td class="summary">
<p>The #string should be [user name]:[password] to use for the connection to the
HTTP proxy.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).OPT_PUT">curl.OPT_PUT</a></td>
		<td class="summary">
<p>A #boolean set to true tells the library to use HTTP PUT to transfer data.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).OPT_QUOTE">curl.OPT_QUOTE</a></td>
		<td class="summary">
<p>Pass a list of FTP or SFTP commands to pass to the server prior to your FTP request.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).OPT_RANDOM_FILE">curl.OPT_RANDOM_FILE</a></td>
		<td class="summary">
<p>Pass a file name.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).OPT_RANGE">curl.OPT_RANGE</a></td>
		<td class="summary">
<p>Pass a #string as parameter, which should contain the specified range you want.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).OPT_READDATA">curl.OPT_READDATA</a></td>
		<td class="summary">
<p>userparam to pass to the file read function.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).OPT_READFUNCTION">curl.OPT_READFUNCTION</a></td>
		<td class="summary">
<p>This function gets called by libcurl as soon as it needs to read data in
order to send it to the peer.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).OPT_REFERER">curl.OPT_REFERER</a></td>
		<td class="summary">
<p>It will be used to set the Referer:
header in the http request sent to the remote server.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).OPT_RESUME_FROM">curl.OPT_RESUME_FROM</a></td>
		<td class="summary">
<p>The #number contains the offset in number of bytes that you want the transfer to start from.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).OPT_RESUME_FROM_LARGE">curl.OPT_RESUME_FROM_LARGE</a></td>
		<td class="summary">
<p>The #number contains the offset in number of bytes that you want the transfer to start from.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).OPT_SOURCE_POSTQUOTE">curl.OPT_SOURCE_POSTQUOTE</a></td>
		<td class="summary">
<p>I cannot find anything about this...</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).OPT_SOURCE_PREQUOTE">curl.OPT_SOURCE_PREQUOTE</a></td>
		<td class="summary">
<p>I cannot find anything about this...</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).OPT_SOURCE_QUOTE">curl.OPT_SOURCE_QUOTE</a></td>
		<td class="summary">
<p>I cannot find anything about this...</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).OPT_SOURCE_URL">curl.OPT_SOURCE_URL</a></td>
		<td class="summary">
<p>I cannot find anything about this...</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).OPT_SOURCE_USERPWD">curl.OPT_SOURCE_USERPWD</a></td>
		<td class="summary">
<p>Login details #string for the connection.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).OPT_SSLCERT">curl.OPT_SSLCERT</a></td>
		<td class="summary">
<p>The #string should be the file name of your certificate.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).OPT_SSLCERTTYPE">curl.OPT_SSLCERTTYPE</a></td>
		<td class="summary">
<p>The #string should be the format of your certificate.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).OPT_SSLENGINE">curl.OPT_SSLENGINE</a></td>
		<td class="summary">
<p>It will be used as the identifier for the crypto engine you want to use for your private key.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).OPT_SSLENGINE_DEFAULT">curl.OPT_SSLENGINE_DEFAULT</a></td>
		<td class="summary">
<p>Sets the actual crypto engine as the default for (asymmetric) crypto operations.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).OPT_SSLKEY">curl.OPT_SSLKEY</a></td>
		<td class="summary">
<p>The #string should be the file name of your private key.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).OPT_SSLKEYPASSWD">curl.OPT_SSLKEYPASSWD</a></td>
		<td class="summary">
<p>It will be used as the password required to use the <a href="##(curl).OPT_SSLKEY">curl.OPT_SSLKEY</a> or
private key.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).OPT_SSLKEYTYPE">curl.OPT_SSLKEYTYPE</a></td>
		<td class="summary">
<p>The #string should be the format of your private key.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).OPT_SSLVERSION">curl.OPT_SSLVERSION</a></td>
		<td class="summary">
<p>Pass a number as parameter to control what version of SSL/TLS to attempt to use.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).OPT_SSL_CIPHER_LIST">curl.OPT_SSL_CIPHER_LIST</a></td>
		<td class="summary">
<p>Pass a #string holding the list of ciphers to use for the SSL connection.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).OPT_SSL_VERIFYHOST">curl.OPT_SSL_VERIFYHOST</a></td>
		<td class="summary">
<p>This option determines whether libcurl verifies that the server cert is for the server it is known as.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).OPT_SSL_VERIFYPEER">curl.OPT_SSL_VERIFYPEER</a></td>
		<td class="summary">
<p>This option determines whether curl verifies the authenticity of the peer's certificate.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).OPT_TCP_NODELAY">curl.OPT_TCP_NODELAY</a></td>
		<td class="summary">
<p>Pass a #number specifying whether the <a href="##(curl).OPT_TCP_NODELAY">curl.OPT<em>TCP</em>NODELAY</a> option is to be set or
cleared (true = set, false = clear).</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).OPT_TELNETOPTIONS">curl.OPT_TELNETOPTIONS</a></td>
		<td class="summary">
<p>Provide a pointer to a list with variables to pass to the telnet negotiations.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).OPT_TIMECONDITION">curl.OPT_TIMECONDITION</a></td>
		<td class="summary">
<p>This defines how the <a href="##(curl).OPT_TIMEVALUE">curl.OPT_TIMEVALUE</a> time value is treated.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).OPT_TIMEOUT">curl.OPT_TIMEOUT</a></td>
		<td class="summary">
<p>Pass a #number as parameter containing the maximum time in seconds that you
allow the libcurl transfer operation to take.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).OPT_TIMEVALUE">curl.OPT_TIMEVALUE</a></td>
		<td class="summary">
<p>This should be the time in seconds since 1 Jan 1970,
and the time will be used in a condition as specified with <a href="##(curl).OPT_TIMECONDITION">curl.OPT_TIMECONDITION</a>.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).OPT_TRANSFERTEXT">curl.OPT_TRANSFERTEXT</a></td>
		<td class="summary">
<p>A #boolean set to true tells the library to use ASCII mode for FTP
transfers, instead of the default binary transfer.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).OPT_UNRESTRICTED_AUTH">curl.OPT_UNRESTRICTED_AUTH</a></td>
		<td class="summary">
<p>A #boolean set to true tells the library it can continue to send
authentication (user+password) when following locations, even when hostname
changed.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).OPT_UPLOAD">curl.OPT_UPLOAD</a></td>
		<td class="summary">
<p>A parameter set to 1 tells the library to prepare for an upload.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).OPT_URL">curl.OPT_URL</a></td>
		<td class="summary">
<p>The URL used to receive/send data.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).OPT_USERAGENT">curl.OPT_USERAGENT</a></td>
		<td class="summary">
<p>It will be used to set the User-Agent:
header in the http request sent to the remote server.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).OPT_USERPWD">curl.OPT_USERPWD</a></td>
		<td class="summary">
<p><br /> <em>needs:</em> #string</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).OPT_VERBOSE">curl.OPT_VERBOSE</a></td>
		<td class="summary">
<p>Set the parameter to true to get the library to display a lot of verbose
information about its operations.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).OPT_WRITEDATA">curl.OPT_WRITEDATA</a></td>
		<td class="summary">
<p>userparam to pass to the file write function.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).OPT_WRITEFUNCTION">curl.OPT_WRITEFUNCTION</a></td>
		<td class="summary">
<p>This function gets called by libcurl as soon as there is data received that
needs to be saved.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).OPT_WRITEINFO">curl.OPT_WRITEINFO</a></td>
		<td class="summary">
<p>I am not sure...</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).OUT_OF_MEMORY">curl.OUT_OF_MEMORY</a></td>
		<td class="summary">
<p>Its a selfdescribing error...</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).PARTIAL_FILE">curl.PARTIAL_FILE</a></td>
		<td class="summary">
<p>Its a selfdescribing error...</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).PROXY_HTTP">curl.PROXY_HTTP</a></td>
		<td class="summary">
<p>HTTP-type proxy <br />
Used for <a href="##(curl).OPT_PROXYTYPE">curl.OPT_PROXYTYPE</a></p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).PROXY_SOCKS4">curl.PROXY_SOCKS4</a></td>
		<td class="summary">
<p>SOCKS4-type proxy <br />
Used for <a href="##(curl).OPT_PROXYTYPE">curl.OPT_PROXYTYPE</a></p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).PROXY_SOCKS5">curl.PROXY_SOCKS5</a></td>
		<td class="summary">
<p>SOCKS5-type proxy <br />
Used for <a href="##(curl).OPT_PROXYTYPE">curl.OPT_PROXYTYPE</a></p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).PTRCONTENTS">curl.PTRCONTENTS</a></td>
		<td class="summary">
<p>The actual data to send away.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).PTRNAME">curl.PTRNAME</a></td>
		<td class="summary">
<p>The #string provides the pointer-name.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).READFUNC_ABORT">curl.READFUNC_ABORT</a></td>
		<td class="summary">
<p>Aborts the read-function.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).READ_ERROR">curl.READ_ERROR</a></td>
		<td class="summary">
<p>Its a selfdescribing error...</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).SEND_ERROR">curl.SEND_ERROR</a></td>
		<td class="summary">
<p>Its a selfdescribing error...</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).SEND_FAIL_REWIND">curl.SEND_FAIL_REWIND</a></td>
		<td class="summary">
<p>Its a selfdescribing error...</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).SHARE_IN_USE">curl.SHARE_IN_USE</a></td>
		<td class="summary">
<p>Its a selfdescribing error...</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).SSLVERSION_DEFAULT">curl.SSLVERSION_DEFAULT</a></td>
		<td class="summary">
<p>The default action.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).SSLVERSION_SSLv2">curl.SSLVERSION_SSLv2</a></td>
		<td class="summary">
<p>Force SSLv2 <br />
Used for <a href="##(curl).OPT_SSLVERSION">curl.OPT_SSLVERSION</a></p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).SSLVERSION_SSLv3">curl.SSLVERSION_SSLv3</a></td>
		<td class="summary">
<p>Force SSLv3 <br />
Used for <a href="##(curl).OPT_SSLVERSION">curl.OPT_SSLVERSION</a></p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).SSLVERSION_TLSv1">curl.SSLVERSION_TLSv1</a></td>
		<td class="summary">
<p>Force TLSv1 <br />
Used for <a href="##(curl).OPT_SSLVERSION">curl.OPT_SSLVERSION</a></p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).SSL_CACERT">curl.SSL_CACERT</a></td>
		<td class="summary">
<p>Its a selfdescribing error...</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).SSL_CERTPROBLEM">curl.SSL_CERTPROBLEM</a></td>
		<td class="summary">
<p>Its a selfdescribing error...</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).SSL_CIPHER">curl.SSL_CIPHER</a></td>
		<td class="summary">
<p>Its a selfdescribing error...</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).SSL_CONNECT_ERROR">curl.SSL_CONNECT_ERROR</a></td>
		<td class="summary">
<p>Its a selfdescribing error...</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).SSL_ENGINE_INITFAILED">curl.SSL_ENGINE_INITFAILED</a></td>
		<td class="summary">
<p>Its a selfdescribing error...</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).SSL_ENGINE_NOTFOUND">curl.SSL_ENGINE_NOTFOUND</a></td>
		<td class="summary">
<p>Its a selfdescribing error...</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).SSL_ENGINE_SETFAILED">curl.SSL_ENGINE_SETFAILED</a></td>
		<td class="summary">
<p>Its a selfdescribing error...</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).SSL_PEER_CERTIFICATE">curl.SSL_PEER_CERTIFICATE</a></td>
		<td class="summary">
<p>UNDOCUMENTED/NOTHING FOUND</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).TELNET_OPTION_SYNTAX">curl.TELNET_OPTION_SYNTAX</a></td>
		<td class="summary">
<p>Its a selfdescribing error...</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).TIMECOND_IFMODSINCE">curl.TIMECOND_IFMODSINCE</a></td>
		<td class="summary">
<p>Condition: If modified since ?</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).TIMECOND_IFUNMODSINCE">curl.TIMECOND_IFUNMODSINCE</a></td>
		<td class="summary">
<p>Condition: If unmodified since ?</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).TIMECOND_LASTMOD">curl.TIMECOND_LASTMOD</a></td>
		<td class="summary">
<p>Condition: last modified <br />
Used for <a href="##(curl).OPT_TIMECONDITION">curl.OPT_TIMECONDITION</a></p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).TIMECOND_NONE">curl.TIMECOND_NONE</a></td>
		<td class="summary">
<p>No time condition <br />
Used for <a href="##(curl).OPT_TIMECONDITION">curl.OPT_TIMECONDITION</a></p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).TOO_MANY_REDIRECTS">curl.TOO_MANY_REDIRECTS</a></td>
		<td class="summary">
<p>Its a selfdescribing error...</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).UNKNOWN_TELNET_OPTION">curl.UNKNOWN_TELNET_OPTION</a></td>
		<td class="summary">
<p>Its a selfdescribing error...</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).UNSUPPORTED_PROTOCOL">curl.UNSUPPORTED_PROTOCOL</a></td>
		<td class="summary">
<p>Its a selfdescribing error...</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).URL_MALFORMAT">curl.URL_MALFORMAT</a></td>
		<td class="summary">
<p>Its a selfdescribing error...</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).URL_MALFORMAT_USER">curl.URL_MALFORMAT_USER</a></td>
		<td class="summary">
<p>Its a selfdescribing error...</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).WRITE_ERROR">curl.WRITE_ERROR</a></td>
		<td class="summary">
<p>Its a selfdescribing error...</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl)._COPYRIGHT">curl._COPYRIGHT</a></td>
		<td class="summary">
<p>Copyright information of this module.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl)._CURLVERSION">curl._CURLVERSION</a></td>
		<td class="summary">
<p>The current used CURL version for this module.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl)._DESCRIPTION">curl._DESCRIPTION</a></td>
		<td class="summary">
<p>A description of this module.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl)._NAME">curl._NAME</a></td>
		<td class="summary">
<p>The name of this module.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl)._SUPPORTED_CURLVERSION">curl._SUPPORTED_CURLVERSION</a></td>
		<td class="summary">
<p>The supported CURL version of this module.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl)._VERSION">curl._VERSION</a></td>
		<td class="summary">
<p>The current version of luacurl.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).escape">curl.escape(url)</a></td>
		<td class="summary">
<p>Escapes URL #strings.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).new">curl.new()</a></td>
		<td class="summary">
<p>Use this function to instantiate curl objects.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curl).unescape">curl.unescape(url)</a></td>
		<td class="summary">
<p>Unescapes URL encoding in #strings. </p>
</td>
		</tr>
	</table>

			<h2><a id="#(curlobj)">Type <code>curlobj</code></a></h2>
				<table class="function_list">
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curlobj).close">curlobj.close()</a></td>
		<td class="summary">
<p>This function closes a curl connection created by <a href="##(curl).new">curl.new</a></p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curlobj).getinfo">curlobj.getinfo(info)</a></td>
		<td class="summary">
<p>Get informations for the <a href="##(curlobj)">#curlobj</a>.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curlobj).perform">curlobj.perform()</a></td>
		<td class="summary">
<p>Call this method to perform a file transfer after all <a href="##(curlobj).setopt">curlobj.setopt</a> calls are made.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(curlobj).setopt">curlobj.setopt(option, ...)</a></td>
		<td class="summary">
<p>Sets options for the <a href="##(curlobj)">#curlobj</a> to be used on the <a href="##(curlobj).perform">curlobj.perform</a> function.</p>
</td>
		</tr>
	</table>

	<h2><a id="#(luacurl)" >Type <code>luacurl</code></a></h2>
	
			<h2><a id="#(#)" >Type <code>#</code></a></h2>
				
<p>The CURL-object to used for curl-actions and settings</p>


			<h2><a id="#(curl)" >Type <code>curl</code></a></h2>
				<h3>Field(s)</h3>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).ABORTED_BY_CALLBACK" >
<strong>curl.ABORTED_BY_CALLBACK</strong>
</a>
</dt>
<dd>
	
<p>Its a selfdescribing error...</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).ARRAY" >
<strong>curl.ARRAY</strong>
</a>
</dt>
<dd>
	
<p>Another possibility to send options is the <a href="##(curl).ARRAY">curl.ARRAY</a> option, that
passes a #table of valid options.</p>

	
<p>Each curl_forms structure element has a
CURLformoption and a char pointer. The final element in the array must be
a <a href="##(curl).END">curl.END</a>. All available options can be used in an array, except the
<a href="##(curl).ARRAY">curl.ARRAY</a> option itself! The last argument in such an array must always
be <a href="##(curl).END">curl.END</a>.
<br /> <em>needs:</em> #table (with  at end)</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).AUTH_ANY" >
<strong>curl.AUTH_ANY</strong>
</a>
</dt>
<dd>
	
<p>This is a convenience macro that sets all bits and thus makes libcurl pick any it finds suitable.</p>

	
<p>libcurl will automatically select the one it finds most secure. <br />
Used for <a href="##(curl).OPT_HTTPAUTH">curl.OPT_HTTPAUTH</a></p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).AUTH_ANYSAFE" >
<strong>curl.AUTH_ANYSAFE</strong>
</a>
</dt>
<dd>
	
<p>This is a convenience macro that sets all bits except Basic and thus makes
libcurl pick any it finds suitable.</p>

	
<p>libcurl will automatically select the
one it finds most secure. <br />
Used for <a href="##(curl).OPT_HTTPAUTH">curl.OPT_HTTPAUTH</a></p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).AUTH_BASIC" >
<strong>curl.AUTH_BASIC</strong>
</a>
</dt>
<dd>
	
<p>HTTP Basic authentication.</p>

	
<p>This is the default choice, and the only method that is in wide-spread use
and supported virtually everywhere. This sends the user name and password
over the network in plain text, easily captured by others. <br />
Used for <a href="##(curl).OPT_HTTPAUTH">curl.OPT_HTTPAUTH</a></p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).AUTH_DIGEST" >
<strong>curl.AUTH_DIGEST</strong>
</a>
</dt>
<dd>
	
<p>HTTP Digest authentication.</p>

	
<p>Digest authentication is defined in <a target="_blank" href="http://tools.ietf.org/html/rfc2617">RFC 2617</a>
and is a more secure way to do authentication over public networks than the
regular old-fashioned Basic method. <br />
Used for <a href="##(curl).OPT_HTTPAUTH">curl.OPT_HTTPAUTH</a></p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).AUTH_GSSNEGOTIATE" >
<strong>curl.AUTH_GSSNEGOTIATE</strong>
</a>
</dt>
<dd>
	
<p>HTTP GSS-Negotiate authentication.</p>

	
<p>The GSS-Negotiate (also known as plain "Negotiate")
method was designed by Microsoft and is used in their web applications. It is
primarily meant as a support for Kerberos5 authentication but may also be
used along with other authentication methods. For more information see IETF
draft <a target="_blank" href="http://tools.ietf.org/html/draft-brezak-spnego-http-04">draft-brezak-spnego-http-04.txt</a>. <br />
<br />
You need to build libcurl with a suitable GSS-API library for this to work. <br />
Used for <a href="##(curl).OPT_HTTPAUTH">curl.OPT_HTTPAUTH</a></p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).AUTH_NONE" >
<strong>curl.AUTH_NONE</strong>
</a>
</dt>
<dd>
	
<p>No HTTP authentication.</p>

	
<p><br />
Used for <a href="##(curl).OPT_HTTPAUTH">curl.OPT_HTTPAUTH</a></p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).AUTH_NTLM" >
<strong>curl.AUTH_NTLM</strong>
</a>
</dt>
<dd>
	
<p>HTTP NTLM authentication.</p>

	
<p>A proprietary protocol invented and used by Microsoft. It uses a
challenge-response and hash concept similar to Digest, to prevent the
password from being eavesdropped. <br />
You need to build libcurl with either OpenSSL, GnuTLS or NSS support for this
option to work, or build libcurl on Windows with SSPI support. <br />
Used for <a href="##(curl).OPT_HTTPAUTH">curl.OPT_HTTPAUTH</a></p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).BAD_CALLING_ORDER" >
<strong>curl.BAD_CALLING_ORDER</strong>
</a>
</dt>
<dd>
	
<p>Its a selfdescribing error...</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).BAD_CONTENT_ENCODING" >
<strong>curl.BAD_CONTENT_ENCODING</strong>
</a>
</dt>
<dd>
	
<p>Its a selfdescribing error...</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).BAD_DOWNLOAD_RESUME" >
<strong>curl.BAD_DOWNLOAD_RESUME</strong>
</a>
</dt>
<dd>
	
<p>Its a selfdescribing error...</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).BAD_FUNCTION_ARGUMENT" >
<strong>curl.BAD_FUNCTION_ARGUMENT</strong>
</a>
</dt>
<dd>
	
<p>Its a selfdescribing error...</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).BAD_PASSWORD_ENTERED" >
<strong>curl.BAD_PASSWORD_ENTERED</strong>
</a>
</dt>
<dd>
	
<p>Its a selfdescribing error...</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).BUFFER" >
<strong>curl.BUFFER</strong>
</a>
</dt>
<dd>
	
<p>It tells libcurl that the file contents are already present in a buffer.</p>

	
<p>This is used for custom file upload parts without use of <a href="##(curl).FILE">curl.FILE</a>. <br />
<br /> <em>needs:</em> #string (filename)</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).BUFFERLENGTH" >
<strong>curl.BUFFERLENGTH</strong>
</a>
</dt>
<dd>
	
<p>The parameter is a #number which gives the length of the buffer.</p>

	
<p>This is used in combination with <a href="##(curl).BUFFER">curl.BUFFER</a>. <br />
<br /> <em>needs:</em> #number</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).BUFFERPTR" >
<strong>curl.BUFFERPTR</strong>
</a>
</dt>
<dd>
	
<p>The parameter is a (pointer) to the buffer to be uploaded.</p>

	
<p>This buffer must not be freed until after <a href="##(curlobj).close">curlobj.close</a> is called. You
must also use <a href="##(curl).BUFFERLENGTH">curl.BUFFERLENGTH</a> to set the number of bytes in the buffer. 
This is used in combination with <a href="##(curl).BUFFER">curl.BUFFER</a>.</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).CLOSEPOLICY_CALLBACK" >
<strong>curl.CLOSEPOLICY_CALLBACK</strong>
</a>
</dt>
<dd>
	
<p><em>(obsolete)</em> The callback of <a href="##(curl).OPT_CLOSEPOLICY">curl.OPT_CLOSEPOLICY</a> <br />
Used for <a href="##(curl).OPT_CLOSEPOLICY">curl.OPT_CLOSEPOLICY</a></p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).CLOSEPOLICY_LEAST_RECENTLY_USED" >
<strong>curl.CLOSEPOLICY_LEAST_RECENTLY_USED</strong>
</a>
</dt>
<dd>
	
<p><em>(obsolete)</em> The least recently used close-policy <br />
Used for <a href="##(curl).OPT_CLOSEPOLICY">curl.OPT_CLOSEPOLICY</a></p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).CLOSEPOLICY_LEAST_TRAFFIC" >
<strong>curl.CLOSEPOLICY_LEAST_TRAFFIC</strong>
</a>
</dt>
<dd>
	
<p><em>(obsolete)</em> The least traffic using close-policy <br />
Used for <a href="##(curl).OPT_CLOSEPOLICY">curl.OPT_CLOSEPOLICY</a></p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).CLOSEPOLICY_OLDEST" >
<strong>curl.CLOSEPOLICY_OLDEST</strong>
</a>
</dt>
<dd>
	
<p><em>(obsolete)</em> The oldest close-policy <br />
Used for <a href="##(curl).OPT_CLOSEPOLICY">curl.OPT_CLOSEPOLICY</a></p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).CLOSEPOLICY_SLOWEST" >
<strong>curl.CLOSEPOLICY_SLOWEST</strong>
</a>
</dt>
<dd>
	
<p><em>(obsolete)</em> The slowest close-policy <br />
Used for <a href="##(curl).OPT_CLOSEPOLICY">curl.OPT_CLOSEPOLICY</a></p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).CONTENTHEADER" >
<strong>curl.CONTENTHEADER</strong>
</a>
</dt>
<dd>
	
<p>Specifies extra headers for the form POST section.</p>

	
<p>This takes a #table. The list must exist while the POST occurs, if you free
it before the post completes you may experience problems. <br />
<br />
When you've passed the HttpPost pointer to <a href="##(curlobj).setopt">curlobj.setopt</a> (using the
<a href="##(curl).OPT_HTTPPOST">curl.OPT_HTTPPOST</a> option), you must not free the list until after you've
called <a href="##(curlobj).close">curlobj.close</a> for the curl handle.
<br /> <em>needs:</em> #table</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).CONTENTSLENGTH" >
<strong>curl.CONTENTSLENGTH</strong>
</a>
</dt>
<dd>
	
<p>The length of the contents.</p>

	
<p><br /> <em>needs:</em> #number</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).CONTENTTYPE" >
<strong>curl.CONTENTTYPE</strong>
</a>
</dt>
<dd>
	
<p>The #string which provides the content-type for this part, possibly instead
of an internally chosen one.</p>

	
<p><br />
This is used in combination with <a href="##(curl).FILE">curl.FILE</a>. <br />
<br /> <em>needs:</em> #string</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).COPYCONTENTS" >
<strong>curl.COPYCONTENTS</strong>
</a>
</dt>
<dd>
	
<p>The actual data to send away.</p>

	
<p>libcurl copies the provided data, so your application doesn't need to
keep it around after this function call. If the data isn't null terminated,
or if you'd like it to contain zero bytes, you must set the length of the
name with <a href="##(curl).CONTENTSLENGTH">curl.CONTENTSLENGTH</a>. <br />
<br /> <em>needs:</em> #table</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).COPYNAME" >
<strong>curl.COPYNAME</strong>
</a>
</dt>
<dd>
	
<p>The #string provides the copy-name.</p>

	
<p>libcurl copies the string so your application doesn't need to keep it around
after this function call. <br />
<br /> <em>needs:</em> #string</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).COULDNT_CONNECT" >
<strong>curl.COULDNT_CONNECT</strong>
</a>
</dt>
<dd>
	
<p>Its a selfdescribing error...</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).COULDNT_RESOLVE_HOST" >
<strong>curl.COULDNT_RESOLVE_HOST</strong>
</a>
</dt>
<dd>
	
<p>Its a selfdescribing error...</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).COULDNT_RESOLVE_PROXY" >
<strong>curl.COULDNT_RESOLVE_PROXY</strong>
</a>
</dt>
<dd>
	
<p>Its a selfdescribing error...</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).CURL_FORMADD_DISABLED" >
<strong>curl.CURL_FORMADD_DISABLED</strong>
</a>
</dt>
<dd>
	
<p>UNDOCUMENTED/NOTHING FOUND</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).CURL_FORMADD_ILLEGAL_ARRAY" >
<strong>curl.CURL_FORMADD_ILLEGAL_ARRAY</strong>
</a>
</dt>
<dd>
	
<p>UNDOCUMENTED/NOTHING FOUND</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).CURL_FORMADD_INCOMPLETE" >
<strong>curl.CURL_FORMADD_INCOMPLETE</strong>
</a>
</dt>
<dd>
	
<p>UNDOCUMENTED/NOTHING FOUND</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).CURL_FORMADD_MEMORY" >
<strong>curl.CURL_FORMADD_MEMORY</strong>
</a>
</dt>
<dd>
	
<p>UNDOCUMENTED/NOTHING FOUND</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).CURL_FORMADD_NULL" >
<strong>curl.CURL_FORMADD_NULL</strong>
</a>
</dt>
<dd>
	
<p>UNDOCUMENTED/NOTHING FOUND</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).CURL_FORMADD_OK" >
<strong>curl.CURL_FORMADD_OK</strong>
</a>
</dt>
<dd>
	
<p>UNDOCUMENTED/NOTHING FOUND</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).CURL_FORMADD_OPTION_TWICE" >
<strong>curl.CURL_FORMADD_OPTION_TWICE</strong>
</a>
</dt>
<dd>
	
<p>UNDOCUMENTED/NOTHING FOUND</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).CURL_FORMADD_UNKNOWN_OPTION" >
<strong>curl.CURL_FORMADD_UNKNOWN_OPTION</strong>
</a>
</dt>
<dd>
	
<p>UNDOCUMENTED/NOTHING FOUND</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).END" >
<strong>curl.END</strong>
</a>
</dt>
<dd>
	
<p>Put this at the end of the #table passed to <a href="curl.ARRAY.html">curl.ARRAY</a>.</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).FAILED_INIT" >
<strong>curl.FAILED_INIT</strong>
</a>
</dt>
<dd>
	
<p>Its a selfdescribing error...</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).FILE" >
<strong>curl.FILE</strong>
</a>
</dt>
<dd>
	
<p>Makes this part a file upload part.</p>

	
<p>It sets the filename field to the basename of the provided filename, it
reads the contents of the file and passes them as data and sets the
content-type if the given file match one of the internally known file
extensions. For <a href="##(curl).FILE">curl.FILE</a> the user may send one or more files in one
part by providing multiple <a href="##(curl).FILE">curl.FILE</a> arguments each followed by the
filename (and each <a href="##(curl).FILE">curl.FILE</a> is allowed to have a <a href="##(curl).CONTENTTYPE">curl.CONTENTTYPE</a>). <br />
<br /> <em>needs:</em> #string (filename)</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).FILECONTENT" >
<strong>curl.FILECONTENT</strong>
</a>
</dt>
<dd>
	
<p>Causes that file to be read and its contents used as data in this part.</p>

	
<p>This part does <em>not</em> automatically become a file upload part simply because
its data was read from a file. <br />
<br /> <em>needs:</em> #string (filename)</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).FILENAME" >
<strong>curl.FILENAME</strong>
</a>
</dt>
<dd>
	
<p>The #string tells libcurl to use the given string as the filename in the
file upload part instead of the actual file name.</p>

	
<p><br />
This is used in combination with <a href="##(curl).FILE">curl.FILE</a>. <br />
<br /> <em>needs:</em> #string</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).FILESIZE_EXCEEDED" >
<strong>curl.FILESIZE_EXCEEDED</strong>
</a>
</dt>
<dd>
	
<p>Its a selfdescribing error...</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).FILE_COULDNT_READ_FILE" >
<strong>curl.FILE_COULDNT_READ_FILE</strong>
</a>
</dt>
<dd>
	
<p>Its a selfdescribing error...</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).FTPAUTH_DEFAULT" >
<strong>curl.FTPAUTH_DEFAULT</strong>
</a>
</dt>
<dd>
	
<p>Allow libcurl to decide.</p>

	
<p><br />
Used for <a href="##(curl).OPT_FTPSSLAUTH">curl.OPT_FTPSSLAUTH</a></p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).FTPAUTH_SSL" >
<strong>curl.FTPAUTH_SSL</strong>
</a>
</dt>
<dd>
	
<p>Try "AUTH SSL" first, and only if that fails try "AUTH TLS".</p>

	
<p><br />
Used for <a href="##(curl).OPT_FTPSSLAUTH">curl.OPT_FTPSSLAUTH</a></p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).FTPAUTH_TLS" >
<strong>curl.FTPAUTH_TLS</strong>
</a>
</dt>
<dd>
	
<p>Try "AUTH TLS" first, and only if that fails try "AUTH SSL".</p>

	
<p><br />
Used for <a href="##(curl).OPT_FTPSSLAUTH">curl.OPT_FTPSSLAUTH</a></p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).FTPSSL_ALL" >
<strong>curl.FTPSSL_ALL</strong>
</a>
</dt>
<dd>
	
<p>Require SSL for all communication.</p>

	
<p><br />
Used for <a href="##(curl).OPT_FTP_SSL">curl.OPT<em>FTP</em>SSL</a></p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).FTPSSL_CONTROL" >
<strong>curl.FTPSSL_CONTROL</strong>
</a>
</dt>
<dd>
	
<p>Require SSL for the control connection.</p>

	
<p><br />
Used for <a href="##(curl).OPT_FTP_SSL">curl.OPT<em>FTP</em>SSL</a></p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).FTPSSL_NONE" >
<strong>curl.FTPSSL_NONE</strong>
</a>
</dt>
<dd>
	
<p>Don't attempt to use SSL.</p>

	
<p><br />
Used for <a href="##(curl).OPT_FTP_SSL">curl.OPT<em>FTP</em>SSL</a></p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).FTPSSL_TRY" >
<strong>curl.FTPSSL_TRY</strong>
</a>
</dt>
<dd>
	
<p>Try using SSL, proceed as normal otherwise.</p>

	
<p><br />
Used for <a href="##(curl).OPT_FTP_SSL">curl.OPT<em>FTP</em>SSL</a></p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).FTP_ACCESS_DENIED" >
<strong>curl.FTP_ACCESS_DENIED</strong>
</a>
</dt>
<dd>
	
<p>Its a selfdescribing error...</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).FTP_CANT_GET_HOST" >
<strong>curl.FTP_CANT_GET_HOST</strong>
</a>
</dt>
<dd>
	
<p>Its a selfdescribing error...</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).FTP_CANT_RECONNECT" >
<strong>curl.FTP_CANT_RECONNECT</strong>
</a>
</dt>
<dd>
	
<p>Its a selfdescribing error...</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).FTP_COULDNT_GET_SIZE" >
<strong>curl.FTP_COULDNT_GET_SIZE</strong>
</a>
</dt>
<dd>
	
<p>Its a selfdescribing error...</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).FTP_COULDNT_RETR_FILE" >
<strong>curl.FTP_COULDNT_RETR_FILE</strong>
</a>
</dt>
<dd>
	
<p>Its a selfdescribing error...</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).FTP_COULDNT_SET_ASCII" >
<strong>curl.FTP_COULDNT_SET_ASCII</strong>
</a>
</dt>
<dd>
	
<p>Its a selfdescribing error...</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).FTP_COULDNT_SET_BINARY" >
<strong>curl.FTP_COULDNT_SET_BINARY</strong>
</a>
</dt>
<dd>
	
<p>Its a selfdescribing error...</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).FTP_COULDNT_STOR_FILE" >
<strong>curl.FTP_COULDNT_STOR_FILE</strong>
</a>
</dt>
<dd>
	
<p>Its a selfdescribing error...</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).FTP_COULDNT_USE_REST" >
<strong>curl.FTP_COULDNT_USE_REST</strong>
</a>
</dt>
<dd>
	
<p>Its a selfdescribing error...</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).FTP_PORT_FAILED" >
<strong>curl.FTP_PORT_FAILED</strong>
</a>
</dt>
<dd>
	
<p>Its a selfdescribing error...</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).FTP_QUOTE_ERROR" >
<strong>curl.FTP_QUOTE_ERROR</strong>
</a>
</dt>
<dd>
	
<p>Its a selfdescribing error...</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).FTP_SSL_FAILED" >
<strong>curl.FTP_SSL_FAILED</strong>
</a>
</dt>
<dd>
	
<p>Its a selfdescribing error...</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).FTP_USER_PASSWORD_INCORRECT" >
<strong>curl.FTP_USER_PASSWORD_INCORRECT</strong>
</a>
</dt>
<dd>
	
<p>Its a selfdescribing error...</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).FTP_WEIRD_227_FORMAT" >
<strong>curl.FTP_WEIRD_227_FORMAT</strong>
</a>
</dt>
<dd>
	
<p>Its a selfdescribing error...</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).FTP_WEIRD_PASS_REPLY" >
<strong>curl.FTP_WEIRD_PASS_REPLY</strong>
</a>
</dt>
<dd>
	
<p>Its a selfdescribing error...</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).FTP_WEIRD_PASV_REPLY" >
<strong>curl.FTP_WEIRD_PASV_REPLY</strong>
</a>
</dt>
<dd>
	
<p>Its a selfdescribing error...</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).FTP_WEIRD_SERVER_REPLY" >
<strong>curl.FTP_WEIRD_SERVER_REPLY</strong>
</a>
</dt>
<dd>
	
<p>Its a selfdescribing error...</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).FTP_WEIRD_USER_REPLY" >
<strong>curl.FTP_WEIRD_USER_REPLY</strong>
</a>
</dt>
<dd>
	
<p>Its a selfdescribing error...</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).FTP_WRITE_ERROR" >
<strong>curl.FTP_WRITE_ERROR</strong>
</a>
</dt>
<dd>
	
<p>Its a selfdescribing error...</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).FUNCTION_NOT_FOUND" >
<strong>curl.FUNCTION_NOT_FOUND</strong>
</a>
</dt>
<dd>
	
<p>Its a selfdescribing error...</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).GOT_NOTHING" >
<strong>curl.GOT_NOTHING</strong>
</a>
</dt>
<dd>
	
<p>Its a selfdescribing error...</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).HTTP_POST_ERROR" >
<strong>curl.HTTP_POST_ERROR</strong>
</a>
</dt>
<dd>
	
<p>Its a selfdescribing error...</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).HTTP_RANGE_ERROR" >
<strong>curl.HTTP_RANGE_ERROR</strong>
</a>
</dt>
<dd>
	
<p>Its a selfdescribing error...</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).HTTP_RETURNED_ERROR" >
<strong>curl.HTTP_RETURNED_ERROR</strong>
</a>
</dt>
<dd>
	
<p>Its a selfdescribing error...</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).HTTP_VERSION_1_0" >
<strong>curl.HTTP_VERSION_1_0</strong>
</a>
</dt>
<dd>
	
<p>Enforce HTTP 1.0 requests.</p>

	
<p><br />
Used for <a href="##(curl).OPT_HTTP_VERSION">curl.OPT<em>HTTP</em>VERSION</a></p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).HTTP_VERSION_1_1" >
<strong>curl.HTTP_VERSION_1_1</strong>
</a>
</dt>
<dd>
	
<p>Enforce HTTP 1.1 requests.</p>

	
<p><br />
Used for <a href="##(curl).OPT_HTTP_VERSION">curl.OPT<em>HTTP</em>VERSION</a></p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).HTTP_VERSION_NONE" >
<strong>curl.HTTP_VERSION_NONE</strong>
</a>
</dt>
<dd>
	
<p>We don't care about what version the library uses.</p>

	
<p>libcurl will use whatever it thinks fit. <br />
Used for <a href="##(curl).OPT_HTTP_VERSION">curl.OPT<em>HTTP</em>VERSION</a></p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).INFO_CONNECT_TIME" >
<strong>curl.INFO_CONNECT_TIME</strong>
</a>
</dt>
<dd>
	
<p>The time, in seconds, it took from the start until the connect to the remote host (or proxy) was completed.</p>

	
<p><br /> Used as parameter for <a href="##(curlobj).getinfo">curlobj.getinfo</a></p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).INFO_CONTENT_LENGTH_DOWNLOAD" >
<strong>curl.INFO_CONTENT_LENGTH_DOWNLOAD</strong>
</a>
</dt>
<dd>
	
<p>The content-length of the download.</p>

	
<p>This is the value read from the Content-Length: field.
Since 7.19.4, this returns -1 if the size isn't known.
<br /> Used as parameter for <a href="##(curlobj).getinfo">curlobj.getinfo</a></p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).INFO_CONTENT_LENGTH_UPLOAD" >
<strong>curl.INFO_CONTENT_LENGTH_UPLOAD</strong>
</a>
</dt>
<dd>
	
<p>The specified size of the upload.</p>

	
<p>Since 7.19.4, this returns -1 if the size isn't known.
<br /> Used as parameter for <a href="##(curlobj).getinfo">curlobj.getinfo</a></p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).INFO_CONTENT_TYPE" >
<strong>curl.INFO_CONTENT_TYPE</strong>
</a>
</dt>
<dd>
	
<p>The content-type of the downloaded object.</p>

	
<p>This is the value read from the Content-Type: field. If you get #nil, it
means that the server didn't send a valid Content-Type header or that the
protocol used doesn't support this.
<br /> Used as parameter for <a href="##(curlobj).getinfo">curlobj.getinfo</a></p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).INFO_COOKIELIST" >
<strong>curl.INFO_COOKIELIST</strong>
</a>
</dt>
<dd>
	
<p>Pass a #table of all cookies cURL knows (expired ones, too).</p>

	
<p>If there are no cookies (cookies for the handle have not been enabled or
simply none have been received) it will return  #nil. (Added in 7.14.1)
<br /> Used as parameter for <a href="##(curlobj).getinfo">curlobj.getinfo</a></p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).INFO_EFFECTIVE_URL" >
<strong>curl.INFO_EFFECTIVE_URL</strong>
</a>
</dt>
<dd>
	
<p>The last used effective URL.</p>

	
<p><br /> Used as parameter for <a href="##(curlobj).getinfo">curlobj.getinfo</a></p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).INFO_FILETIME" >
<strong>curl.INFO_FILETIME</strong>
</a>
</dt>
<dd>
	
<p>The remote time of the retrieved document
(in number of seconds since 1 Jan 1970 in the GMT/UTC time zone).</p>

	
<p>If you get -1, it can be because of many reasons (unknown, the server hides
it or the server doesn't support the command that tells document time etc)
and the time of the document is unknown. Note that you must tell the server
to collect this information before the transfer is made, by using the
<a href="##(curl).OPT_FILETIME">curl.OPT_FILETIME</a> option to <a href="##(curlobj).setopt">curlobj.setopt</a> or you will unconditionally
get a -1 back. (Added in 7.5)
<br /> Used as parameter for <a href="##(curlobj).getinfo">curlobj.getinfo</a></p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).INFO_HEADER_SIZE" >
<strong>curl.INFO_HEADER_SIZE</strong>
</a>
</dt>
<dd>
	
<p>The total size of all the headers received.</p>

	
<p>Measured in number of bytes.
<br /> Used as parameter for <a href="##(curlobj).getinfo">curlobj.getinfo</a></p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).INFO_HTTPAUTH_AVAIL" >
<strong>curl.INFO_HTTPAUTH_AVAIL</strong>
</a>
</dt>
<dd>
	
<p>Bitmask indicating the authentication method(s) available.</p>

	
<p>The meaning of the bits is explained in the <a href="##(curl).OPT_HTTPAUTH">curl.OPT_HTTPAUTH</a> option
for <a href="##(curlobj).setopt">curlobj.setopt</a>. (Added in 7.10.8)
<br /> Used as parameter for <a href="##(curlobj).getinfo">curlobj.getinfo</a></p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).INFO_HTTP_CONNECTCODE" >
<strong>curl.INFO_HTTP_CONNECTCODE</strong>
</a>
</dt>
<dd>
	
<p>The last received proxy response code to a CONNECT request.</p>

	
<p><br /> Used as parameter for <a href="##(curlobj).getinfo">curlobj.getinfo</a></p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).INFO_LASTSOCKET" >
<strong>curl.INFO_LASTSOCKET</strong>
</a>
</dt>
<dd>
	
<p>The last socket used by this curl session.</p>

	
<p>If the socket is no longer valid, -1 is returned. When you finish working
with the socket, you must call <a href="##(curlobj).close">curlobj.close</a> as usual and let libcurl
close the socket and cleanup other resources associated with the handle. <br />
<br />
<em>NOTE:</em> this API is not really working on win64, since the SOCKET type on
win64 is 64 bit large while its 'long' is only 32 bits.
<br /> Used as parameter for <a href="##(curlobj).getinfo">curlobj.getinfo</a></p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).INFO_NAMELOOKUP_TIME" >
<strong>curl.INFO_NAMELOOKUP_TIME</strong>
</a>
</dt>
<dd>
	
<p>The time, in seconds, it took from the start until the name resolving was completed.</p>

	
<p><br /> Used as parameter for <a href="##(curlobj).getinfo">curlobj.getinfo</a></p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).INFO_NONE" >
<strong>curl.INFO_NONE</strong>
</a>
</dt>
<dd>
	

<p><br /> Used as parameter for <a href="##(curlobj).getinfo">curlobj.getinfo</a></p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).INFO_NUM_CONNECTS" >
<strong>curl.INFO_NUM_CONNECTS</strong>
</a>
</dt>
<dd>
	
<p>How many new connections libcurl had to create to achieve the previous
transfer (only the successful connects are counted).</p>

	
<p>Combined with
<a href="##(curl).INFO_REDIRECT_COUNT">curl.INFO<em>REDIRECT</em>COUNT</a> you are able to know how many times libcurl
successfully reused existing connection(s) or not. See the Connection Options
of <a href="##(curlobj).setopt">curlobj.setopt</a> to see how libcurl tries to make persistent connections
to save time. (Added in 7.12.3) 
<br /> Used as parameter for <a href="##(curlobj).getinfo">curlobj.getinfo</a></p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).INFO_OS_ERRNO" >
<strong>curl.INFO_OS_ERRNO</strong>
</a>
</dt>
<dd>
	
<p>The errno variable from a connect failure.</p>

	
<p>Note that the value is only set on failure, it is not reset upon a successful
operation. (Added in 7.12.2)
<br /> Used as parameter for <a href="##(curlobj).getinfo">curlobj.getinfo</a></p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).INFO_PRETRANSFER_TIME" >
<strong>curl.INFO_PRETRANSFER_TIME</strong>
</a>
</dt>
<dd>
	
<p>The time, in seconds, it took from the start until the file transfer is just about to begin.</p>

	
<p>This includes all pre-transfer commands and negotiations that are specific
to the particular protocol(s) involved. It does not involve the sending of
the protocol- specific request that triggers a transfer.
<br /> Used as parameter for <a href="##(curlobj).getinfo">curlobj.getinfo</a></p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).INFO_PRIVATE" >
<strong>curl.INFO_PRIVATE</strong>
</a>
</dt>
<dd>
	
<p>The pointer to the private data associated with the curl handle.</p>

	
<p>As <a href="##(curl).OPT_PRIVATE">curl.OPT_PRIVATE</a> is missing, you can't use it...
<br /> Used as parameter for <a href="##(curlobj).getinfo">curlobj.getinfo</a></p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).INFO_PROXYAUTH_AVAIL" >
<strong>curl.INFO_PROXYAUTH_AVAIL</strong>
</a>
</dt>
<dd>
	
<p>Bitmask indicating the authentication method(s) available for your proxy
authentication.</p>

	
<p>(Added in 7.10.8)
<br /> Used as parameter for <a href="##(curlobj).getinfo">curlobj.getinfo</a></p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).INFO_REDIRECT_COUNT" >
<strong>curl.INFO_REDIRECT_COUNT</strong>
</a>
</dt>
<dd>
	
<p>The total number of redirections that were actually followed.</p>

	
<p>(Added in 7.9.7)
<br /> Used as parameter for <a href="##(curlobj).getinfo">curlobj.getinfo</a></p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).INFO_REDIRECT_TIME" >
<strong>curl.INFO_REDIRECT_TIME</strong>
</a>
</dt>
<dd>
	
<p>The total time, in seconds, it took for all redirection steps include name
lookup, connect, pretransfer and transfer before final transaction was started.</p>

	
<h1>curl.INFO<em>REDIRECT</em>TIME} contains the complete execution time for multiple</h1>
<p>redirections. (Added in 7.9.7)
<br /> Used as parameter for <a href="##(curlobj).getinfo">curlobj.getinfo</a></p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).INFO_REQUEST_SIZE" >
<strong>curl.INFO_REQUEST_SIZE</strong>
</a>
</dt>
<dd>
	
<p>The total size of the issued requests.</p>

	
<p>This is so far only for HTTP requests.
Note that this may be more than one request if FOLLOWLOCATION is true.
<br /> Used as parameter for <a href="##(curlobj).getinfo">curlobj.getinfo</a></p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).INFO_RESPONSE_CODE" >
<strong>curl.INFO_RESPONSE_CODE</strong>
</a>
</dt>
<dd>
	
<p>The last received HTTP, FTP or SMTP response code.</p>

	
<p>This option was previously known as CURLINFO<em>HTTP</em>CODE in libcurl 7.10.7
and earlier. The value will be zero if no server response code has been
received. Note that a proxy's CONNECT response should be read with
<a href="##(curl).INFO_HTTP_CONNECTCODE">curl.INFO<em>HTTP</em>CONNECTCODE</a> and not this.
<br /> Used as parameter for <a href="##(curlobj).getinfo">curlobj.getinfo</a></p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).INFO_SIZE_DOWNLOAD" >
<strong>curl.INFO_SIZE_DOWNLOAD</strong>
</a>
</dt>
<dd>
	
<p>The total amount of bytes that were downloaded.</p>

	
<p>The amount is only for the latest transfer and will be reset again for each new transfer.
<br /> Used as parameter for <a href="##(curlobj).getinfo">curlobj.getinfo</a></p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).INFO_SIZE_UPLOAD" >
<strong>curl.INFO_SIZE_UPLOAD</strong>
</a>
</dt>
<dd>
	
<p>The total amount of bytes that were uploaded.</p>

	
<p><br /> Used as parameter for <a href="##(curlobj).getinfo">curlobj.getinfo</a></p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).INFO_SPEED_DOWNLOAD" >
<strong>curl.INFO_SPEED_DOWNLOAD</strong>
</a>
</dt>
<dd>
	
<p>The average download speed that curl measured for the complete download.</p>

	
<p>Measured in bytes/second.
<br /> Used as parameter for <a href="##(curlobj).getinfo">curlobj.getinfo</a></p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).INFO_SPEED_UPLOAD" >
<strong>curl.INFO_SPEED_UPLOAD</strong>
</a>
</dt>
<dd>
	
<p>The average upload speed that curl measured for the complete upload.</p>

	
<p>Measured in bytes/second.
<br /> Used as parameter for <a href="##(curlobj).getinfo">curlobj.getinfo</a></p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).INFO_SSL_ENGINES" >
<strong>curl.INFO_SSL_ENGINES</strong>
</a>
</dt>
<dd>
	
<p>Pass a #table of OpenSSL crypto-engines supported.</p>

	
<p>Note that engines are normally implemented in separate dynamic libraries.
Hence not all the returned engines may be available at run-time.
<br /> Used as parameter for <a href="##(curlobj).getinfo">curlobj.getinfo</a></p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).INFO_SSL_VERIFYRESULT" >
<strong>curl.INFO_SSL_VERIFYRESULT</strong>
</a>
</dt>
<dd>
	
<p>The result of the certification verification that was requested
(using the <a href="##(curl).OPT_SSL_VERIFYPEER">curl.OPT<em>SSL</em>VERIFYPEER</a> option to <a href="##(curlobj).setopt">curlobj.setopt</a>).</p>

	
<p><br /> Used as parameter for <a href="##(curlobj).getinfo">curlobj.getinfo</a></p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).INFO_STARTTRANSFER_TIME" >
<strong>curl.INFO_STARTTRANSFER_TIME</strong>
</a>
</dt>
<dd>
	
<p>The time, in seconds, it took from the start until the first byte is received by libcurl.</p>

	
<p>This includes <a href="##(curl).INFO_PRETRANSFER_TIME">curl.INFO<em>PRETRANSFER</em>TIME</a> and also the time the server
needs to calculate the result.
<br /> Used as parameter for <a href="##(curlobj).getinfo">curlobj.getinfo</a></p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).INFO_TOTAL_TIME" >
<strong>curl.INFO_TOTAL_TIME</strong>
</a>
</dt>
<dd>
	
<p>The total time in seconds for the previous transfer, including name resolving, TCP connect etc.</p>

	
<p><br /> Used as parameter for <a href="##(curlobj).getinfo">curlobj.getinfo</a></p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).INTERFACE_FAILED" >
<strong>curl.INTERFACE_FAILED</strong>
</a>
</dt>
<dd>
	
<p>Its a selfdescribing error...</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).IOCMD_NOP" >
<strong>curl.IOCMD_NOP</strong>
</a>
</dt>
<dd>
	
<p>UNDOCUMENTED/NOTHING FOUND</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).IOCMD_RESTARTREAD" >
<strong>curl.IOCMD_RESTARTREAD</strong>
</a>
</dt>
<dd>
	
<p>UNDOCUMENTED/NOTHING FOUND</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).IOE_FAILRESTART" >
<strong>curl.IOE_FAILRESTART</strong>
</a>
</dt>
<dd>
	
<p>UNDOCUMENTED/NOTHING FOUND</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).IOE_OK" >
<strong>curl.IOE_OK</strong>
</a>
</dt>
<dd>
	
<p>UNDOCUMENTED/NOTHING FOUND</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).IOE_UNKNOWNCMD" >
<strong>curl.IOE_UNKNOWNCMD</strong>
</a>
</dt>
<dd>
	
<p>UNDOCUMENTED/NOTHING FOUND</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).IPRESOLVE_V4" >
<strong>curl.IPRESOLVE_V4</strong>
</a>
</dt>
<dd>
	
<p>Resolve to IPv4 addresses.</p>

	
<p><br />
Used for <a href="##(curl).OPT_IPRESOLVE">curl.OPT_IPRESOLVE</a></p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).IPRESOLVE_V6" >
<strong>curl.IPRESOLVE_V6</strong>
</a>
</dt>
<dd>
	
<p>Resolve to IPv6 addresses.</p>

	
<p><br />
Used for <a href="##(curl).OPT_IPRESOLVE">curl.OPT_IPRESOLVE</a></p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).IPRESOLVE_WHATEVER" >
<strong>curl.IPRESOLVE_WHATEVER</strong>
</a>
</dt>
<dd>
	
<p>Default, resolves addresses to all IP versions that your system allows.</p>

	
<p><br />
Used for <a href="##(curl).OPT_IPRESOLVE">curl.OPT_IPRESOLVE</a></p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).LDAP_CANNOT_BIND" >
<strong>curl.LDAP_CANNOT_BIND</strong>
</a>
</dt>
<dd>
	
<p>Its a selfdescribing error...</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).LDAP_INVALID_URL" >
<strong>curl.LDAP_INVALID_URL</strong>
</a>
</dt>
<dd>
	
<p>Its a selfdescribing error...</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).LDAP_SEARCH_FAILED" >
<strong>curl.LDAP_SEARCH_FAILED</strong>
</a>
</dt>
<dd>
	
<p>Its a selfdescribing error...</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).LIBRARY_NOT_FOUND" >
<strong>curl.LIBRARY_NOT_FOUND</strong>
</a>
</dt>
<dd>
	
<p>Its a selfdescribing error...</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).LOGIN_DENIED" >
<strong>curl.LOGIN_DENIED</strong>
</a>
</dt>
<dd>
	
<p>Its a selfdescribing error...</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).MALFORMAT_USER" >
<strong>curl.MALFORMAT_USER</strong>
</a>
</dt>
<dd>
	
<p>Its a selfdescribing error...</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).NAMELENGTH" >
<strong>curl.NAMELENGTH</strong>
</a>
</dt>
<dd>
	
<p>UNDOCUMENTED/NOTHING FOUND</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).NETRC_IGNORED" >
<strong>curl.NETRC_IGNORED</strong>
</a>
</dt>
<dd>
	
<p>The library will ignore the file and use only the information in the URL.</p>

	
<p>This is the default. <br />
Used for <a href="##(curl).OPT_NETRC">curl.OPT_NETRC</a></p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).NETRC_OPTIONAL" >
<strong>curl.NETRC_OPTIONAL</strong>
</a>
</dt>
<dd>
	
<p>The use of your ~/.netrc file is optional, and information in the URL is to be preferred.</p>

	
<p>The file will be scanned for the host and user name (to find the password only)
or for the host only, to find the first user name and password after that
machine, which ever information is not specified in the URL. <br />
<br />
Undefined values of the option will have this effect. <br />
Used for <a href="##(curl).OPT_NETRC">curl.OPT_NETRC</a></p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).NETRC_REQUIRED" >
<strong>curl.NETRC_REQUIRED</strong>
</a>
</dt>
<dd>
	
<p>This value tells the library that use of the file is required, to ignore
the information in the <a href="##(curl).OPT_URL">curl.OPT_URL</a>, and to search the file for the host
only.</p>

	
<p><br />
Used for <a href="##(curl).OPT_NETRC">curl.OPT_NETRC</a></p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).OBSOLETE" >
<strong>curl.OBSOLETE</strong>
</a>
</dt>
<dd>
	
<p>UNDOCUMENTED/NOTHING FOUND</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).OBSOLETE2" >
<strong>curl.OBSOLETE2</strong>
</a>
</dt>
<dd>
	
<p>UNDOCUMENTED/NOTHING FOUND</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).OK" >
<strong>curl.OK</strong>
</a>
</dt>
<dd>
	
<p>Returnd by any <a href="##(curl)">#curl</a> related function to say anything went well.</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).OPERATION_TIMEOUTED" >
<strong>curl.OPERATION_TIMEOUTED</strong>
</a>
</dt>
<dd>
	
<p>Its a selfdescribing error...</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).OPT_AUTOREFERER" >
<strong>curl.OPT_AUTOREFERER</strong>
</a>
</dt>
<dd>
	
<p>Pass a #boolean set to true to enable this.</p>

	
<p>When enabled, libcurl will automatically set the Referer: field in requests
where it follows a Location: redirect. 
<br /> <em>needs:</em> #boolean</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).OPT_BUFFERSIZE" >
<strong>curl.OPT_BUFFERSIZE</strong>
</a>
</dt>
<dd>
	
<p>Pass a #number specifying your preferred size (in bytes) for the receive
buffer in libcurl.</p>

	
<p>The main point of this would be that the write callback
gets called more often and with smaller chunks. This is just treated as a
request, not an order. You cannot be guaranteed to actually get the given
size. (Added in 7.10) <br />
<br /> <em>needs:</em> #number</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).OPT_CAINFO" >
<strong>curl.OPT_CAINFO</strong>
</a>
</dt>
<dd>
	
<p>Pass a #string naming a file holding one or more certificates to verify the peer with.</p>

	
<p>This makes sense only when used in combination with the <a href="##(curl).OPT_SSL_VERIFYPEER">curl.OPT<em>SSL</em>VERIFYPEER</a>
option. If <a href="##(curl).OPT_SSL_VERIFYPEER">curl.OPT<em>SSL</em>VERIFYPEER</a> is zero, <a href="##(curl).OPT_CAINFO">curl.OPT_CAINFO</a> need not
even indicate an accessible file. <br />
<br />
This option is by default set to the system path where libcurl's cacert
bundle is assumed to be stored, as established at build time. <br />
<br />
If curl is built against the NSS SSL library, the NSS PEM PKCS#11 module
(libnsspem.so) needs to be available for this option to work properly. <br />
<br /> <em>needs:</em> #string</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).OPT_CAPATH" >
<strong>curl.OPT_CAPATH</strong>
</a>
</dt>
<dd>
	
<p>Pass a #string naming a directory holding multiple CA certificates to verify the peer with.</p>

	
<p>If libcurl is built against OpenSSL, the certificate directory must be
prepared using the openssl c_rehash utility. This makes sense only when used
in combination with the <a href="##(curl).OPT_SSL_VERIFYPEER">curl.OPT<em>SSL</em>VERIFYPEER</a> option. If <a href="##(curl).OPT_SSL_VERIFYPEER">curl.OPT<em>SSL</em>VERIFYPEER</a>
is zero, <a href="##(curl).OPT_CAPATH">curl.OPT_CAPATH</a> need not even indicate an accessible path.
The <a href="##(curl).OPT_CAPATH">curl.OPT_CAPATH</a> function apparently does not work in Windows due to
some limitation in openssl. This option is OpenSSL-specific and does nothing
if libcurl is built to use GnuTLS. NSS-powered libcurl provides the option
only for backward compatibility. <br />
<br /> <em>needs:</em> #string</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).OPT_CLOSEPOLICY" >
<strong>curl.OPT_CLOSEPOLICY</strong>
</a>
</dt>
<dd>
	
<p><em>(Obsolete)</em> This option does nothing.</p>

	
<p><br /> <em>needs:</em> #number</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).OPT_CONNECTTIMEOUT" >
<strong>curl.OPT_CONNECTTIMEOUT</strong>
</a>
</dt>
<dd>
	
<p>The #number should contain the maximum time in seconds that you allow the connection to the server to take.</p>

	
<p>This only limits the connection phase, once it has connected, this option is
of no more use. Set to zero to switch to the default built-in connection
timeout - 300 seconds. See also the <a href="##(curl).OPT_TIMEOUT">curl.OPT_TIMEOUT</a> option. <br />
<br />
In unix-like systems, this might cause signals to be used unless <a href="##(curl).OPT_NOSIGNAL">curl.OPT_NOSIGNAL</a>
is set. <br />
<br /> <em>needs:</em> #number</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).OPT_COOKIE" >
<strong>curl.OPT_COOKIE</strong>
</a>
</dt>
<dd>
	
<p>It will be used to set a cookie in the http request.</p>

	
<p>The format of the string should be NAME=CONTENTS, where NAME is the cookie
name and CONTENTS is what the cookie should contain. <br />
<br />
If you need to set multiple cookies, you need to set them all using a single
option and thus you need to concatenate them all in one single string.
Set multiple cookies in one string like this:
"name1=content1; name2=content2;" etc. <br />
<br />
This option sets the cookie header explicitly in the outgoing request(s).
If multiple requests are done due to authentication, followed redirections
or similar, they will all get this cookie passed on. <br />
<br />
Using this option multiple times will only make the latest string override
the previous ones. <br />
<br /> <em>needs:</em> #string</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).OPT_COOKIEFILE" >
<strong>curl.OPT_COOKIEFILE</strong>
</a>
</dt>
<dd>
	
<p>The #string should contain the name of your file holding cookie data to read.</p>

	
<p>The cookie data may be in Netscape / Mozilla cookie data format or just
regular HTTP-style headers dumped to a file. <br />
<br />
Given an empty or non-existing file or by passing the empty string (""),
this option will enable cookies for this curl handle, making it understand
and parse received cookies and then use matching cookies in future requests. <br />
<br />
If you use this option multiple times, you just add more files to read.
Subsequent files will add more cookies. <br />
<br /> <em>needs:</em> #string</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).OPT_COOKIEJAR" >
<strong>curl.OPT_COOKIEJAR</strong>
</a>
</dt>
<dd>
	
<p>Pass a file name as #string.</p>

	
<p>This will make libcurl write all internally known cookies to the specified
file when <a href="##(curlobj).close">curlobj.close</a> is called.
If no cookies are known, no file will be created. Specify "-" to instead
have the cookies written to stdout. Using this option also enables cookies
for this session, so if you for example follow a location it will make
matching cookies get sent accordingly. <br />
<br />
If the cookie jar file can't be created or written to (when the 
<a href="##(curlobj).close">curlobj.close</a>  is called), libcurl will not and cannot report an error
for this. Using <a href="##(curl).OPT_VERBOSE">curl.OPT_VERBOSE</a> will get a warning to display, but that
is the only visible feedback you get about this possibly lethal situation. <br />
<br /> <em>needs:</em> #string</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).OPT_COOKIESESSION" >
<strong>curl.OPT_COOKIESESSION</strong>
</a>
</dt>
<dd>
	
<p>Pass a #boolean set to true to mark this as a new cookie "session".</p>

	
<p>It will
force libcurl to ignore all cookies it is about to load that are
"session cookies" from the previous session. By default, libcurl always
stores and loads all cookies, independent if they are session cookies or
not. Session cookies are cookies without expiry date and they are meant to
be alive and existing for this "session" only. <br />
<br /> <em>needs:</em> #boolean</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).OPT_CRLF" >
<strong>curl.OPT_CRLF</strong>
</a>
</dt>
<dd>
	
<p>If the value is set to true, libcurl converts Unix newlines to CRLF newlines on transfers.</p>

	
<p>Disable this option again by setting the value to false. <br />
<br /> <em>needs:</em> #boolean</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).OPT_CUSTOMREQUEST" >
<strong>curl.OPT_CUSTOMREQUEST</strong>
</a>
</dt>
<dd>
	
<p>The #string can be used to specify the request instead of GET or HEAD when
performing HTTP based requests, instead of LIST and NLST when performing
FTP directory listings and instead of LIST and RETR when issuing POP3 based
commands.</p>

	
<p>This is particularly useful, for example, for performing a HTTP
DELETE request or a POP3 DELE command. <br />
<br />
Please don't perform this at will, on HTTP based requests, by making sure
your server supports the command you are sending first. <br />
<br />
When you change the request method by setting <a href="##(curl).OPT_CUSTOMREQUEST">curl.OPT_CUSTOMREQUEST</a>
to something, you don't actually change how libcurl behaves or acts in
regards to the particular request method, it will only change the actual
string sent in the request. <br />
<br />
For example: <br />
+ With the HTTP protocol when you tell libcurl to do a HEAD request, but then
specify a GET though a custom request libcurl will still act as if it sent
a HEAD. To switch to a proper HEAD use <a href="##(curl).OPT_NOBODY">curl.OPT_NOBODY</a>, to switch to a
proper POST use <a href="##(curl).OPT_POST">curl.OPT_POST</a> or <a href="##(curl).OPT_POSTFIELDS">curl.OPT_POSTFIELDS</a> and to switch
to a proper GET use <a href="##(curl).OPT_HTTPGET">curl.OPT_HTTPGET</a>. <br />
+ With the POP3 protocol when you tell libcurl to use a custom request it
will behave like a LIST or RETR command was sent where it expects data to
be returned by the server. As such <a href="##(curl).OPT_NOBODY">curl.OPT_NOBODY</a> should be used when
specifying commands such as DELE and NOOP for example. <br />
<br />
Restore to the internal default by setting this to #nil. <br />
<br />
Many people have wrongly used this option to replace the entire request
with their own, including multiple headers and POST contents. While that
might work in many cases, it will cause libcurl to send invalid requests
and it could possibly confuse the remote server badly. Use
<a href="##(curl).OPT_POST">curl.OPT_POST</a> and <a href="##(curl).OPT_POSTFIELDS">curl.OPT_POSTFIELDS</a> to set POST data. Use
<a href="##(curl).OPT_HTTPHEADER">curl.OPT_HTTPHEADER</a> to replace or extend the set of headers sent by
libcurl. Use <a href="##(curl).OPT_HTTP_VERSION">curl.OPT<em>HTTP</em>VERSION</a> to change HTTP version. <br />
<br /> (Support for POP3 added in 7.26.0) <br /> 
<br /> <em>needs:</em> #string</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).OPT_DNS_CACHE_TIMEOUT" >
<strong>curl.OPT_DNS_CACHE_TIMEOUT</strong>
</a>
</dt>
<dd>
	
<p>This sets the timeout in seconds.</p>

	
<p>Name resolves will be kept in memory for
this #number of seconds. Set to zero to completely disable caching, or set to
-1 to make the cached entries remain forever. By default, libcurl caches
this info for 60 seconds. <br />
<br />
The name resolve functions of various libc implementations don't re-read
name server information unless explicitly told so. This may cause libcurl to
keep using the older server even if DHCP has updated the server info, and
this may look like a DNS cache issue to the casual libcurl-app user. <br /> 
<br /> <em>needs:</em> #number</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).OPT_DNS_USE_GLOBAL_CACHE" >
<strong>curl.OPT_DNS_USE_GLOBAL_CACHE</strong>
</a>
</dt>
<dd>
	
<p>If the value is true, it tells curl to use a global DNS cache that will
survive between easy handle creations and deletions.</p>

	
<p>This is not thread-safe
and this will use a global variable. <br />
<br />
<em>WARNING:</em> This option is considered obsolete. Stop using it. Switch over to
using the share interface instead! (Not implemented in luacurl? Maybe as
OPT<em>DNS</em>USE<em>GLOBAL</em>CACHE?) <br />
<br /> <em>needs:</em> #boolean</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).OPT_EGDSOCKET" >
<strong>curl.OPT_EGDSOCKET</strong>
</a>
</dt>
<dd>
	
<p>Pass a path name to the Entropy Gathering Daemon socket.</p>

	
<p>It will be used to seed the random engine for SSL. <br />
<br /> <em>needs:</em> #string</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).OPT_ENCODING" >
<strong>curl.OPT_ENCODING</strong>
</a>
</dt>
<dd>
	
<p>_It has got an update...</p>

	
<p>I cannot say which number means which string!_
Sets the contents of the Accept-Encoding: header sent in a HTTP request,
and enables decoding of a response when a Content-Encoding: header is received.
Three encodings are supported: <br />
+ identity : which does nothing <br />
+ deflate : which requests the server to compress its response using the zlib algorithm <br />
+ gzip which requests the gzip algorithm <br />
If a zero-length string is set, then an Accept-Encoding: header containing all supported encodings is sent. <br />
<br />
This is a request, not an order; the server may or may not do it.
This option must be set (to any non-#nil value) or else any unsolicited
encoding done by the server is ignored. (perhaps not in Lua available: See
the special file lib/README.encoding for details.) <br />
<br /> <em>needs:</em> #string</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).OPT_FAILONERROR" >
<strong>curl.OPT_FAILONERROR</strong>
</a>
</dt>
<dd>
	
<p>A parameter set to true tells the library to fail silently if the HTTP code
returned is equal to or larger than 400.</p>

	
<p>The default action would be to
return the page normally, ignoring that code. <br />
<br />
This method is not fail-safe and there are occasions where non-successful
response codes will slip through, especially when authentication is involved
(response codes 401 and 407). <br />
<br />
You might get some amounts of headers transferred before this situation is
detected, like when a "100-continue" is received as a response to a POST/PUT
and a 401 or 407 is received immediately afterwards. <br />
<br /> <em>needs:</em> #boolean</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).OPT_FILETIME" >
<strong>curl.OPT_FILETIME</strong>
</a>
</dt>
<dd>
	
<p>If the #boolean is true, libcurl will attempt to get the modification date
of the remote document in this operation.</p>

	
<p>This requires that the remote
server sends the time or replies to a time querying command. The <a href="curl.getinfo.html">curl.getinfo</a>
function with the <a href="curl.INFO_FILETIME.html">curl.INFO_FILETIME</a> argument can be used after a
transfer to extract the received time (if any). <br />
<br /> <em>needs:</em> #boolean</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).OPT_FOLLOWLOCATION" >
<strong>curl.OPT_FOLLOWLOCATION</strong>
</a>
</dt>
<dd>
	
<p>A #boolean set to true tells the library to follow any Location:
header that the server sends as part of a HTTP header.</p>

	
<p><br />
<br />
This means that the library will re-send the same request on the new
location and follow new Location: headers all the way until no more such
headers are returned. <a href="##(curl).OPT_MAXREDIRS">curl.OPT_MAXREDIRS</a> can be used to limit the number of
redirects libcurl will follow. <br />
<br />
Since 7.19.4, libcurl can limit what protocols it will automatically follow.
<br /> <em>needs:</em> #boolean</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).OPT_FORBID_REUSE" >
<strong>curl.OPT_FORBID_REUSE</strong>
</a>
</dt>
<dd>
	
<p>Set to ture to make the next transfer explicitly close the connection when done.</p>

	
<p>Normally, libcurl keeps all connections alive when done with one transfer in
case a succeeding one follows that can re-use them. This option should be
used with caution and only if you understand what it does. <br />
Set to false to have libcurl keep the connection open for possible later re-use (default behavior). <br />
<br /> <em>needs:</em> #boolean</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).OPT_FRESH_CONNECT" >
<strong>curl.OPT_FRESH_CONNECT</strong>
</a>
</dt>
<dd>
	
<p>Set to true to make the next transfer use a new (fresh) connection by force.</p>

	
<p>If the connection cache is full before this connection, one of the existing
connections will be closed as according to the selected or default policy.
This option should be used with caution and only if you understand what it
does. <br />
Set this to false to have libcurl attempt re-using an existing connection
(default behavior).  <br />
<br /> <em>needs:</em> #boolean</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).OPT_FTPAPPEND" >
<strong>curl.OPT_FTPAPPEND</strong>
</a>
</dt>
<dd>
	
<p>A parameter set to true tells the library to append to the remote file instead of overwrite it.</p>

	
<p>This is only useful when uploading to an FTP site. <br />
<br /> <em>needs:</em> #boolean</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).OPT_FTPLISTONLY" >
<strong>curl.OPT_FTPLISTONLY</strong>
</a>
</dt>
<dd>
	
<p>A parameter set to true tells the library to just list the names of files in
a directory, instead of doing a full directory listing that would include
file sizes, dates etc.</p>

	
<p>This works for FTP and SFTP URLs. <br />
<br />
This causes an FTP NLST command to be sent on an FTP server. Beware that some
FTP servers list only files in their response to NLST; they might not include
subdirectories and symbolic links. <br />
<br />
Setting this option to true also implies a directory listing even if the URL
doesn't end with a slash, which otherwise is necessary. <br /> 
<br /> <em>needs:</em> #boolean</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).OPT_FTPPORT" >
<strong>curl.OPT_FTPPORT</strong>
</a>
</dt>
<dd>
	
<p>The #string will be used to get the IP address to use for the FTP PORT instruction.</p>

	
<p>The PORT instruction tells the remote server to connect to our specified
IP address. The string may be a plain IP address, a host name, a network
interface name (under Unix) or just a '-' symbol to let the library use your
system's default IP address. Default FTP operations are passive, and thus
won't use PORT. <br />
<br />
The address can be followed by a ':' to specify a port, optionally followed
by a '-' to specify a port range. If the port specified is 0, the operating
system will pick a free port. If a range is provided and all ports in the
range are not available, libcurl will report <a href="##(curl).FTP_PORT_FAILED">curl.FTP<em>PORT</em>FAILED</a> for
the handle. Invalid port/range settings are ignored. IPv6 addresses followed
by a port or portrange have to be in brackets. IPv6 addresses without
port/range specifier can be in brackets. (added in 7.19.5) <br />
<br />
Examples with specified ports: <br />
'eth0:0' <br />
'192.168.1.2:32000-33000' <br />
'curl.se:32123' <br />
'[::1]:1234-4567'' <br />
<br />
You disable PORT again and go back to using the passive version by
setting this option to #nil. <br /> 
<br /> <em>needs:</em> #string</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).OPT_FTPSSLAUTH" >
<strong>curl.OPT_FTPSSLAUTH</strong>
</a>
</dt>
<dd>
	
<p>Pass a #number using one of the values from below, to alter how libcurl
issues "AUTH TLS" or "AUTH SSL" when FTP over SSL is activated .</p>

	
<p>(Added in 7.12.2) <br />
<br />
<em>Values:</em> <br />
+ <a href="##(curl).FTPAUTH_DEFAULT">curl.FTPAUTH_DEFAULT</a> : Allow libcurl to decide. <br />
+ <a href="##(curl).FTPAUTH_SSL">curl.FTPAUTH_SSL</a> : Try "AUTH SSL" first, and only if that fails try "AUTH TLS". <br />
+ <a href="##(curl).FTPAUTH_TLS">curl.FTPAUTH_TLS</a> : Try "AUTH TLS" first, and only if that fails try "AUTH SSL". <br />
<br /> <em>needs:</em> #number</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).OPT_FTP_ACCOUNT" >
<strong>curl.OPT_FTP_ACCOUNT</strong>
</a>
</dt>
<dd>
	
<p>When an FTP server asks for "account data" after user name and password has
been provided, this data is sent off using the ACCT command.</p>

	
<p>(Added in 7.13.0) <br />
<br /> <em>needs:</em> #string</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).OPT_FTP_CREATE_MISSING_DIRS" >
<strong>curl.OPT_FTP_CREATE_MISSING_DIRS</strong>
</a>
</dt>
<dd>
	
<p>If the value is true, curl will attempt to create any remote directory that
it fails to CWD into.</p>

	
<p>CWD is the command that changes working directory. (Added in 7.10.7) <br />
<br />
This setting also applies to SFTP-connections. curl will attempt to create
the remote directory if it can't obtain a handle to the target-location.
The creation will fail if a file of the same name as the directory to create
already exists or lack of permissions prevents creation. (Added in 7.16.3) <br /> 
<br /> <em>needs:</em> #boolean</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).OPT_FTP_RESPONSE_TIMEOUT" >
<strong>curl.OPT_FTP_RESPONSE_TIMEOUT</strong>
</a>
</dt>
<dd>
	
<p>Causes curl to set a timeout period (in seconds) on the amount of time that
the server is allowed to take in order to generate a response message for a
command before the session is considered hung.</p>

	
<p>While curl is waiting for a
response, this value overrides <a href="##(curl).OPT_TIMEOUT">curl.OPT_TIMEOUT</a>. It is recommended that
if used in conjunction with <a href="##(curl).OPT_TIMEOUT">curl.OPT_TIMEOUT</a>, you set
<a href="##(curl).OPT_FTP_RESPONSE_TIMEOUT">curl.OPT<em>FTP</em>RESPONSE_TIMEOUT</a> to a value smaller than <a href="##(curl).OPT_TIMEOUT">curl.OPT_TIMEOUT</a>.
(Added in 7.10.8) <br />
<br /> <em>needs:</em> #number</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).OPT_FTP_SSL" >
<strong>curl.OPT_FTP_SSL</strong>
</a>
</dt>
<dd>
	
<p>Pass a #number using one of the values from below, to make libcurl use your
desired level of SSL for the transfer.</p>

	
<p>(Added in 7.11.0) <br />
This is for enabling SSL/TLS when you use FTP, SMTP, POP3, IMAP etc. <br />
+ <a href="##(curl).FTPSSL_NONE">curl.FTPSSL_NONE</a> : Don't attempt to use SSL. <br />
+ <a href="##(curl).FTPSSL_TRY">curl.FTPSSL_TRY</a> : Try using SSL, proceed as normal otherwise. <br />
+ <a href="##(curl).FTPSSL_CONTROL">curl.FTPSSL_CONTROL</a> : Require SSL for the control connection or fail with CURLE<em>USE</em>SSL_FAILED. <br />
+ <a href="##(curl).FTPSSL_ALL">curl.FTPSSL_ALL</a> : Require SSL for all communication or fail with CURLE<em>USE</em>SSL_FAILED. <br /> 
<br /> <em>needs:</em> #number</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).OPT_FTP_USE_EPRT" >
<strong>curl.OPT_FTP_USE_EPRT</strong>
</a>
</dt>
<dd>
	
<p>If the value is true, it tells curl to use the EPRT (and LPRT) command when
doing active FTP downloads (which is enabled by <a href="##(curl).OPT_FTPPORT">curl.OPT_FTPPORT</a>).</p>

	
<p>Using EPRT means that it will first attempt to use EPRT and then LPRT before
using PORT, but if you pass zero to this option, it will not try using EPRT
or LPRT, only plain PORT. (Added in 7.10.5) <br />
<br />
If the server is an IPv6 host, this option will have no effect as of 7.12.3. <br />
<br /> <em>needs:</em> #boolean</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).OPT_FTP_USE_EPSV" >
<strong>curl.OPT_FTP_USE_EPSV</strong>
</a>
</dt>
<dd>
	
<p>If the value is true, it tells curl to use the EPSV command when doing
passive FTP downloads (which it always does by default).</p>

	
<p>Using EPSV means
that it will first attempt to use EPSV before using PASV, but if you pass
zero to this option, it will not try using EPSV, only plain PASV. <br />
<br />
If the server is an IPv6 host, this option will have no effect as of 7.12.3. <br />
<br /> <em>needs:</em> #boolean</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).OPT_HEADER" >
<strong>curl.OPT_HEADER</strong>
</a>
</dt>
<dd>
	
<p>A parameter set to true tells the library to include the header in the body output.</p>

	
<p>This is only relevant for protocols that actually have headers preceding 
<br /> <em>needs:</em> #boolean
<br /> <em>default:</em> false</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).OPT_HEADERDATA" >
<strong>curl.OPT_HEADERDATA</strong>
</a>
</dt>
<dd>
	
<p>Userparam of <a href="##(curl).OPT_HEADERFUNCTION">curl.OPT_HEADERFUNCTION</a>
<br /> <em>needs:</em> userparam</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).OPT_HEADERFUNCTION" >
<strong>curl.OPT_HEADERFUNCTION</strong>
</a>
</dt>
<dd>
	
<p>This function gets called by libcurl as soon as it has received header data.</p>

	
<p>The header callback will be called once for each header and only complete
header lines are passed on to the callback. Parsing headers is very easy
using this. The size of the data pointed to by ptr is size multiplied with
nmemb. Do not assume that the header line is zero terminated! The pointer
named userparam is the one you set with the <a href="##(curl).OPT_HEADERDATA">curl.OPT_HEADERDATA</a> option.
The callback function must return the #number of bytes actually taken care
of. If that amount differs from the amount passed to your function, it'll
signal an error to the library. This will abort the transfer and return
<a href="##(curl).WRITE_ERROR">curl.WRITE_ERROR</a>. <br/>
<br/>
It's important to note that the callback will be invoked for the headers of
all responses received after initiating a request and not just the final
response. This includes all responses which occur during authentication
negotiation. If you need to operate on only the headers from the final
response, you will need to collect headers in the callback yourself and use
HTTP status lines, for example, to delimit response boundaries. <br/>
<br/>
When a server sends a chunked encoded transfer, it may contain a trailer.
That trailer is identical to a HTTP header and if such a trailer is received
it is passed to the application using this callback as well. There are
several ways to detect it being a trailer and not an ordinary header: 1) it
comes after the response-body. 2) it comes after the final header line
(CR LF) 3) a Trailer: header among the regular response-headers mention what
header(s) to expect in the trailer. <br/>
<br/>
For non-HTTP protocols like FTP, POP3, IMAP and SMTP this function will get
called with the server responses to the commands that libcurl sends. <br/>
<br /> <em>returns:</em> #number</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).OPT_HTTP200ALIASES" >
<strong>curl.OPT_HTTP200ALIASES</strong>
</a>
</dt>
<dd>
	
<p>List of aliases to be treated as valid HTTP 200 responses.</p>

	
<p>Some servers respond with a custom header response line. For example,
IceCast servers respond with "ICY 200 OK". By including this string in your
list of aliases, the response will be treated as a valid HTTP header line
such as "HTTP/1.0 200 OK". (Added in 7.10.3) <br />
<br />
The alias itself is not parsed for any version strings. Before libcurl
7.16.3, Libcurl used the value set by option <a href="##(curl).OPT_HTTP_VERSION">curl.OPT<em>HTTP</em>VERSION</a>,
but starting with 7.16.3 the protocol is assumed to match HTTP 1.0 when an
alias matched. <br />
<br /> <em>needs:</em> #string, ..., #string</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).OPT_HTTPAUTH" >
<strong>curl.OPT_HTTPAUTH</strong>
</a>
</dt>
<dd>
	
<p>Pass a long as parameter, which is set to a bitmask, to tell libcurl which
authentication method(s) you want it to use.</p>

	
<p>The available bits are listed
below. If more than one bit is set, libcurl will first query the site to see
which authentication methods it supports and then pick the best one you
allow it to use. For some methods, this will induce an extra network
round-trip. Set the actual name and password with the <a href="##(curl).OPT_USERPWD">curl.OPT_USERPWD</a>
option (or with the CURLOPT<em>USERNAME and the CURLOPT</em>PASSWORD options : NOT IMPLEMENTED??).
(Added in 7.10.6) <br /> 
<br />
Pass a #number, set to one of the values described below. <br />
+ <a href="##(curl).AUTH_BASIC">curl.AUTH_BASIC</a> <br />
+ <a href="##(curl).AUTH_DIGEST">curl.AUTH_DIGEST</a> <br />
+ <a href="##(curl).AUTH_GSSNEGOTIATE">curl.AUTH_GSSNEGOTIATE</a> <br />
+ <a href="##(curl).AUTH_NTLM">curl.AUTH_NTLM</a> <br />
+ <a href="##(curl).AUTH_ANY">curl.AUTH_ANY</a> <br />
+ <a href="##(curl).AUTH_ANYSAFE">curl.AUTH_ANYSAFE</a> <br />
<br /> <em>needs:</em> #number</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).OPT_HTTPGET" >
<strong>curl.OPT_HTTPGET</strong>
</a>
</dt>
<dd>
	
<p>If the #boolean is true, this forces the HTTP request to get back to GET.</p>

	
<p>Usable if a POST, HEAD, PUT, or a custom request has been used previously
using the same curl handle. <br />
<br />
When setting <a href="##(curl).OPT_HTTPGET">curl.OPT_HTTPGET</a> to true, it will automatically set
<a href="##(curl).OPT_NOBODY">curl.OPT_NOBODY</a> to false and <a href="##(curl).OPT_UPLOAD">curl.OPT_UPLOAD</a> to false. <br />
<br /> <em>needs:</em> #boolean</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).OPT_HTTPHEADER" >
<strong>curl.OPT_HTTPHEADER</strong>
</a>
</dt>
<dd>
	
<p>HTTP headers to pass to the server in your HTTP request.</p>

	
<p>If you add a header with no content as in 'Accept:' (no data on the right
side of the colon), the internally used header will get disabled. Thus,
using this option you can add new headers, replace internal headers and
remove internal headers. To add a header with no content (nothing to the
right side of the colon), use the form 'MyHeader;' (note the ending
semicolon). <br />
<br />
The headers included in the list must not be CRLF-terminated, because curl
adds CRLF after each header item. Failure to comply with this will result
in strange bugs because the server will most likely ignore part of the
headers you specified. <br />
<br />
The first line in a request (containing the method, usually a GET or POST)
is not a header and cannot be replaced using this option. Only the lines
following the request-line are headers. Adding this method line in this list
of headers will only cause your request to send an invalid header. <br />
<br />
Pass a #nil to this to reset back to no custom headers. <br />
<br />
The most commonly replaced headers have "shortcuts" in the options
<a href="##(curl).OPT_COOKIE">curl.OPT_COOKIE</a>, <a href="##(curl).OPT_USERAGENT">curl.OPT_USERAGENT</a> and <a href="##(curl).OPT_REFERER">curl.OPT_REFERER</a>. <br />
<br /> <em>needs:</em> #string, ..., #string</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).OPT_HTTPPOST" >
<strong>curl.OPT_HTTPPOST</strong>
</a>
</dt>
<dd>
	
<p>Tells libcurl you want a multipart/formdata HTTP POST to be made and you
instruct what data to pass on to the server.</p>

	
<p>Pass a pointer to a linked list
of curl_httppost structs as parameter. The data in this list must remain
intact until you close this curl handle again with <a href="##(curlobj).close">curlobj.close</a>. <br />
<br />
Using POST with HTTP 1.1 implies the use of a "Expect: 100-continue" header.
You can disable this header with <a href="##(curl).OPT_HTTPHEADER">curl.OPT_HTTPHEADER</a> as usual. <br />
<br />
When setting <a href="##(curl).OPT_HTTPPOST">curl.OPT_HTTPPOST</a>, it will automatically set
<a href="##(curl).OPT_NOBODY">curl.OPT_NOBODY</a> to false (since 7.14.1). <br />
<br /> <em>needs:</em> #string, ..., #string</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).OPT_HTTPPROXYTUNNEL" >
<strong>curl.OPT_HTTPPROXYTUNNEL</strong>
</a>
</dt>
<dd>
	
<p>Set the parameter to true to make the library tunnel all operations through
a given HTTP proxy.</p>

	
<p>There is a big difference between using a proxy and to
tunnel through it. If you don't know what this means, you probably don't
want this tunneling option. <br /> 
<br /> <em>needs:</em> #boolean</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).OPT_HTTP_VERSION" >
<strong>curl.OPT_HTTP_VERSION</strong>
</a>
</dt>
<dd>
	
<p>Pass a #number, set to one of the values described below.</p>

	
<p>They force libcurl to use the specific HTTP versions.
This is not sensible to do unless you have a good reason. <br />
<br />
<em>Values:</em>
+ <a href="##(curl).HTTP_VERSION_NONE">curl.HTTP<em>VERSION</em>NONE</a> : We don't care about what version the library uses. libcurl will use whatever it thinks fit. <br />
+ <a href="##(curl).HTTP_VERSION_1_0">curl.HTTP_VERSION<em>1</em>0</a> : Enforce HTTP 1.0 requests. <br />
+ <a href="##(curl).HTTP_VERSION_1_1">curl.HTTP_VERSION<em>1</em>1</a> : Enforce HTTP 1.1 requests. <br />
<br /> <em>needs:</em> #number</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).OPT_INFILESIZE" >
<strong>curl.OPT_INFILESIZE</strong>
</a>
</dt>
<dd>
	
<p>When uploading a file to a remote site, this option should be used to tell
libcurl what the expected size of the infile is.</p>

	
<p>See also <a href="##(curl).OPT_INFILESIZE_LARGE">curl.OPT<em>INFILESIZE</em>LARGE</a>. <br />
<br />
For uploading using SCP, this option or <a href="##(curl).OPT_INFILESIZE_LARGE">curl.OPT<em>INFILESIZE</em>LARGE</a> is mandatory. <br />
<br />
When sending emails using SMTP, this command can be used to specify the
optional SIZE parameter for the MAIL FROM command. (Added in 7.23.0) <br />
<br />
This option does not limit how much data libcurl will actually send, as
that is controlled entirely by what the read callback returns. <br />
<br /> <em>needs:</em> #number</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).OPT_INFILESIZE_LARGE" >
<strong>curl.OPT_INFILESIZE_LARGE</strong>
</a>
</dt>
<dd>
	
<p>When uploading a file to a remote site, this option should be used to tell
libcurl what the expected size of the infile is.</p>

	
<p><br />
<br />
For uploading using SCP, this option or <a href="##(curl).OPT_INFILESIZE">curl.OPT_INFILESIZE</a> is mandatory. <br />
<br />
This option does not limit how much data libcurl will actually send, as that
is controlled entirely by what the read callback returns. <br />
<br /> <em>needs:</em> #number</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).OPT_INTERFACE" >
<strong>curl.OPT_INTERFACE</strong>
</a>
</dt>
<dd>
	
<p>This sets the interface name to use as outgoing network interface.</p>

	
<p>The name
can be an interface name, an IP address, or a host name. <br />
<br />
Starting with 7.24.0: If the parameter starts with "if!" then it is treated
as only as interface name and no attempt will ever be named to do treat it
as an IP address or to do name resolution on it. If the parameter starts
with "host!" it is treated as either an IP address or a hostname. Hostnames
are resolved synchronously. Using the if! format is highly recommended when
using the multi interfaces to avoid allowing the code to block. If "if!" is
specified but the parameter does not match an existing interface,
<a href="##(curl).INTERFACE_FAILED">curl.INTERFACE_FAILED</a> is returned. 
<br /> <em>needs:</em> #string</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).OPT_IOCTLDATA" >
<strong>curl.OPT_IOCTLDATA</strong>
</a>
</dt>
<dd>
	
<p>Pass a pointer that will be untouched by libcurl and passed as the 3rd
argument in the ioctl callback set with CURLOPT_IOCTLFUNCTION.</p>

	
<p><br />
Userparam of <a href="##(curl).OPT_IOCTLDATA">curl.OPT_IOCTLDATA</a>
<br /> <em>needs:</em> userparam
<br /> <em>default:</em> #nil (Option added in 7.12.3). </p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).OPT_IOCTLFUNCTION" >
<strong>curl.OPT_IOCTLFUNCTION</strong>
</a>
</dt>
<dd>
	
<p>This function gets called by libcurl when something special I/O-related
needs to be done that the library can't do by itself.</p>

	
<p>For now, rewinding the
read data stream is the only action it can request. The rewinding of the
read data stream may be necessary when doing a HTTP PUT or POST with a
multi-pass authentication method. <br />
<br /> <em>needs:</em> function(userparam, command)
<br /> <em>returns:</em>  #number
<br /> <em>default:</em> #nil (Option added in 7.12.3). </p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).OPT_IPRESOLVE" >
<strong>curl.OPT_IPRESOLVE</strong>
</a>
</dt>
<dd>
	
<p>Allows an application to select what kind of IP addresses to use when resolving host names.</p>

	
<p>This is only interesting when using host names that resolve addresses using
more than one version of IP. <br />
<br />
The allowed values are: <br />
<a href="##(curl).IPRESOLVE_WHATEVER">curl.IPRESOLVE_WHATEVER</a> : Default, resolves addresses to all IP versions that your system allows. <br />
<a href="##(curl).CURL_IPRESOLVE_V4">curl.CURL<em>IPRESOLVE</em>V4</a> : Resolve to IPv4 addresses. <br />
<a href="##(curl).IPRESOLVE_V6">curl.IPRESOLVE_V6</a> : Resolve to IPv6 addresses. <br />
<br /> <em>needs:</em> #number</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).OPT_KRB4LEVEL" >
<strong>curl.OPT_KRB4LEVEL</strong>
</a>
</dt>
<dd>
	
<p>_It has got an update...</p>

	
<p>I cannot say which number means which string!_
Set the kerberos security level for FTP; this also enables kerberos awareness.
This is a string (the <a target="_blank" href="http://luacurl.luaforge.net/">doc</a> says "NO!"), 'clear', 'safe', 'confidential' or 'private'.
If the string is set but doesn't match one of these, 'private' will be used.
Set the string to #nil to disable kerberos support for FTP. <br />
<br /> <em>needs:</em> #string</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).OPT_LOW_SPEED_LIMIT" >
<strong>curl.OPT_LOW_SPEED_LIMIT</strong>
</a>
</dt>
<dd>
	
<p>The #number contains the transfer speed in bytes per second that the transfer
should be below during <a href="##(curl).OPT_LOW_SPEED_TIME">curl.OPT<em>LOW</em>SPEED_TIME</a> seconds for the library
to consider it too slow and abort.</p>

	
<p><br />
<br /> <em>needs:</em> #number</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).OPT_LOW_SPEED_TIME" >
<strong>curl.OPT_LOW_SPEED_TIME</strong>
</a>
</dt>
<dd>
	
<p>The #number contains the time in seconds that the transfer should be below
the <a href="##(curl).OPT_LOW_SPEED_LIMIT">curl.OPT<em>LOW</em>SPEED_LIMIT</a> for the library to consider it too slow and abort.</p>

	
<p><br />
<br /> <em>needs:</em> #number</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).OPT_MAXCONNECTS" >
<strong>curl.OPT_MAXCONNECTS</strong>
</a>
</dt>
<dd>
	
<p>The set number will be the persistent connection cache size.</p>

	
<p>The set amount will be the maximum amount of simultaneously open connections
that libcurl may cache in this easy handle. Default is 5, and there isn't
much point in changing this value unless you are perfectly aware of how this
works and changes libcurl's behaviour. This concerns connections using any of
the protocols that support persistent connections. <br />
<br />
When reaching the maximum limit, curl closes the oldest one in the cache to
prevent increasing the number of open connections. <br />
<br />
If you already have performed transfers with this curl handle, setting a
smaller <a href="##(curl).OPT_MAXCONNECTS">curl.OPT_MAXCONNECTS</a> than before may cause open connections to
get closed unnecessarily. <br /> 
<br /> <em>needs:</em> #number</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).OPT_MAXFILESIZE" >
<strong>curl.OPT_MAXFILESIZE</strong>
</a>
</dt>
<dd>
	
<p>This allows you to specify the maximum size (in bytes) of a file to download.</p>

	
<p>If the file requested is larger than this value, the transfer will not start
and <a href="##(curl).FILESIZE_EXCEEDED">curl.FILESIZE_EXCEEDED</a> will be returned. <br />
<br />
The file size is not always known prior to download, and for such files this
option has no effect even if the file transfer ends up being larger than
this given limit. This concerns both FTP and HTTP transfers. <br />
<br /> <em>needs:</em> #number</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).OPT_MAXFILESIZE_LARGE" >
<strong>curl.OPT_MAXFILESIZE_LARGE</strong>
</a>
</dt>
<dd>
	
<p>This allows you to specify the maximum size (in bytes) of a file to download.</p>

	
<p>If the file requested is larger than this value, the transfer will not start
and <a href="##(curl).FILESIZE_EXCEEDED">curl.FILESIZE_EXCEEDED</a> will be returned. (Added in 7.11.0) <br />
<br />
The file size is not always known prior to download, and for such files this
option has no effect even if the file transfer ends up being larger than
this given limit. This concerns both FTP and HTTP transfers. <br />
<br /> <em>needs:</em> #number</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).OPT_MAXREDIRS" >
<strong>curl.OPT_MAXREDIRS</strong>
</a>
</dt>
<dd>
	
<p>Pass a #number.</p>

	
<p>The set #number will be the redirection limit. If that many
redirections have been followed, the next redirect will cause an error
(<a href="##(curl).TOO_MANY_REDIRECTS">curl.TOO<em>MANY</em>REDIRECTS</a>). This option only makes sense if the
<a href="##(curl).OPT_FOLLOWLOCATION">curl.OPT_FOLLOWLOCATION</a> is used at the same time. <br />
Added in 7.15.1: Setting the limit to 0 will make libcurl refuse any
redirect. Set it to -1 for an infinite number of redirects
(which is the default) 
<br /> <em>needs:</em> #number
<br /> <em>default:</em> -1</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).OPT_NETRC" >
<strong>curl.OPT_NETRC</strong>
</a>
</dt>
<dd>
	
<p>This parameter controls the preference of libcurl between using user names
and passwords from your ~/.netrc file, relative to user names and passwords
in the URL supplied with <a href="##(curl).OPT_URL">curl.OPT_URL</a>.</p>

	
<p><br />
libcurl uses a user name (and supplied or prompted password) supplied with
<a href="##(curl).OPT_USERPWD">curl.OPT_USERPWD</a> in preference to any of the options controlled by this
parameter.<br />
Pass a #number, set to one of the values described below. <br />
+ <a href="##(curl).NETRC_OPTIONAL">curl.NETRC_OPTIONAL</a> <br />
+ <a href="##(curl).NETRC_IGNORED">curl.NETRC_IGNORED</a>  <br />
+ <a href="##(curl).NETRC_REQUIRED">curl.NETRC_REQUIRED</a> <br />
<br /> <em>needs:</em> #number
<br /> <em>default:</em> <a href="##(curl).NETRC_IGNORED">curl.NETRC_IGNORED</a></p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).OPT_NETRC_FILE" >
<strong>curl.OPT_NETRC_FILE</strong>
</a>
</dt>
<dd>
	
<p>The full path name to the file you want libcurl to use as .netrc file.</p>

	
<p>If
this option is omitted, and <a href="##(curl).OPT_NETRC">curl.OPT_NETRC</a> is set, libcurl will attempt
to find a &#47;.netrc file in the current user's home directory. (Added in 7.10.9) <br />
<br /> <em>needs:</em> #string</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).OPT_NOBODY" >
<strong>curl.OPT_NOBODY</strong>
</a>
</dt>
<dd>
	
<p>A #boolean set to true tells the library to not include the body-part in the output.</p>

	
<p>This is only relevant for protocols that have separate header and body parts.
On HTTP(S) servers, this will make libcurl do a HEAD request. <br />
<br />
To change request to GET, you should use <a href="##(curl).OPT_HTTPGET">curl.OPT_HTTPGET</a>. Change request
to POST with <a href="##(curl).OPT_POST">curl.OPT_POST</a> etc. <br />
<br /> <em>needs:</em> #boolean</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).OPT_NOPROGRESS" >
<strong>curl.OPT_NOPROGRESS</strong>
</a>
</dt>
<dd>
	
<p>If set to true, it tells the library to shut off the progress
meter completely.</p>

	
<p>It will also prevent the <a href="##(curl).OPT_PROGRESSFUNCTION">curl.OPT_PROGRESSFUNCTION</a> from
getting called..
Future versions of libcurl are likely to not have any built-in progress meter at all. 
<br /> <em>needs:</em> #boolean
<br /> <em>default:</em> true.</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).OPT_NOSIGNAL" >
<strong>curl.OPT_NOSIGNAL</strong>
</a>
</dt>
<dd>
	
<p>If it is true, libcurl will not use any functions that install signal
handlers or any functions that cause signals to be sent to the process.</p>

	
<p>This option is mainly here to allow multi-threaded unix applications to
still set/use all timeout options etc, without risking getting signals. <br />
<br />
If this option is set and libcurl has been built with the standard name
resolver, timeouts will not occur while the name resolve takes place.
Consider building libcurl with c-ares support to enable asynchronous DNS
lookups, which enables nice timeouts for name resolves without signals. <br />
<br />
Setting <a href="##(curl).OPT_NOSIGNAL">curl.OPT_NOSIGNAL</a> to 1 makes libcurl NOT ask the system to ignore
SIGPIPE signals, which otherwise are sent by the system when trying to send
data to a socket which is closed in the other end. libcurl makes an effort
to never cause such SIGPIPEs to trigger, but some operating systems have no
way to avoid them and even on those that have there are some corner cases
when they may still happen, contrary to our desire. In addition, using
CURLAUTH<em>NTLM</em>WB authentication could cause a SIGCHLD signal to be raised. <br />
<br />
<br /> <em>needs:</em> #boolean
<br /> <em>default:</em> false (Added in 7.10)</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).OPT_PORT" >
<strong>curl.OPT_PORT</strong>
</a>
</dt>
<dd>
	
<p>Pass a #number specifying what remote port #number to connect to, instead of
the one specified in the <a href="##(curl).OPT_URL">curl.OPT_URL</a> or the default port for the used protocol.</p>

	
<p><br />
<br /> <em>needs:</em> #number</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).OPT_POST" >
<strong>curl.OPT_POST</strong>
</a>
</dt>
<dd>
	
<p>A #boolean set to true tells the library to do a regular HTTP post.</p>

	
<p>This will also make the library use a
"Content-Type: application/x-www-form-urlencoded" header. (This is by far
the most commonly used POST method). <br />
<br />
Use <a href="##(curl).OPT_POSTFIELDS">curl.OPT_POSTFIELDS</a> option to specify what data to post and
<a href="##(curl).OPT_POSTFIELDSIZE">curl.OPT_POSTFIELDSIZE</a> or <a href="##(curl).OPT_POSTFIELDSIZE_LARGE">curl.OPT<em>POSTFIELDSIZE</em>LARGE</a> to set the data size. <br />
Optionally, you can provide data to POST using the <a href="##(curl).OPT_READFUNCTION">curl.OPT_READFUNCTION</a>
and <a href="##(curl).OPT_READDATA">curl.OPT_READDATA</a> options but then you must make sure to not set
<a href="##(curl).OPT_POSTFIELDS">curl.OPT_POSTFIELDS</a> to anything but #nil. When providing data with a
callback, you must transmit it using chunked transfer-encoding or you must
set the size of the data with the <a href="##(curl).OPT_POSTFIELDSIZE">curl.OPT_POSTFIELDSIZE</a> or
<a href="##(curl).OPT_POSTFIELDSIZE_LARGE">curl.OPT<em>POSTFIELDSIZE</em>LARGE</a> option. To enable chunked encoding, you
simply pass in the appropriate Transfer-Encoding header. <br />
<br />
You can override the default POST Content-Type: header by setting your own
with <a href="##(curl).OPT_HTTPHEADER">curl.OPT_HTTPHEADER</a>. <br />
Using POST with HTTP 1.1 implies the use of a "Expect: 100-continue" header.
You can disable this header with CURLOPT_HTTPHEADER as usual. <br />
If you use POST to a HTTP 1.1 server, you can send data without knowing the
size before starting the POST if you use chunked encoding. You enable this
by adding a header like "Transfer-Encoding: chunked" with <a href="##(curl).OPT_HTTPHEADER">curl.OPT_HTTPHEADER</a>.
With HTTP 1.0 or without chunked transfer, you must specify the size in the
request. <br />
<br />
When setting <a href="##(curl).OPT_POST">curl.OPT_POST</a> to true, it will automatically set
<a href="##(curl).OPT_NOBODY">curl.OPT_NOBODY</a> to false (since 7.14.1). <br />
<br />
If you issue a POST request and then want to make a HEAD or GET using the
same re-used handle, you must explicitly set the new request type using
<a href="##(curl).OPT_NOBODY">curl.OPT_NOBODY</a> or <a href="##(curl).OPT_HTTPGET">curl.OPT_HTTPGET</a> or similar. 
<br /> <em>needs:</em> #boolean</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).OPT_POSTFIELDS" >
<strong>curl.OPT_POSTFIELDS</strong>
</a>
</dt>
<dd>
	
<p>The full data to post in a HTTP POST operation.</p>

	
<p>You must make sure that the data is formatted the way you want the server to
receive it. libcurl will not convert or encode it for you. Most web servers
will assume this data to be url-encoded. <br />
<br />
The data #string are NOT copied by the library: as a consequence, they must
be preserved by the calling application until the transfer finishes. <br />
<br />
This POST is a normal application/x-www-form-urlencoded kind (and libcurl
will set that Content-Type by default when this option is used), which is
the most commonly used one by HTML forms. See also the <a href="##(curl).OPT_POST">curl.OPT_POST</a>.
Using <a href="##(curl).OPT_POSTFIELDS">curl.OPT_POSTFIELDS</a> implies <a href="##(curl).OPT_POST">curl.OPT_POST</a>. <br />
<br />
If you want to do a zero-byte POST, you need to set <a href="##(curl).OPT_POSTFIELDSIZE">curl.OPT_POSTFIELDSIZE</a>
explicitly to zero, as simply setting <a href="##(curl).OPT_POSTFIELDS">curl.OPT_POSTFIELDS</a> to #nil or ""
just effectively disables the sending of the specified string. libcurl will
instead assume that you'll send the POST data using the read callback! <br />
<br />
Using POST with HTTP 1.1 implies the use of a "Expect: 100-continue" header.
You can disable this header with <a href="##(curl).OPT_HTTPHEADER">curl.OPT_HTTPHEADER</a> as usual. <br />
<br />
To make multipart/formdata posts (aka <a target="_blank" href="http://tools.ietf.org/html/rfc2388"> RFC 2388 </a> -posts), check out the
<a href="##(curl).OPT_HTTPPOST">curl.OPT_HTTPPOST</a> option. 
<br /> <em>needs:</em> #string</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).OPT_POSTFIELDSIZE" >
<strong>curl.OPT_POSTFIELDSIZE</strong>
</a>
</dt>
<dd>
	
<p>If you want to post data to the server without letting libcurl do a strlen()
(C-function, similar to string.len() in Lua) to measure the data size, this
option must be used.</p>

	
<p>When this option is used you can post fully binary data,
which otherwise is likely to fail. If this size is set to -1, the library
will use strlen() to get the size. <br /> 
<br /> <em>needs:</em> #number</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).OPT_POSTFIELDSIZE_LARGE" >
<strong>curl.OPT_POSTFIELDSIZE_LARGE</strong>
</a>
</dt>
<dd>
	
<p>Use this to set the size of the <a href="##(curl).OPT_POSTFIELDS">curl.OPT_POSTFIELDS</a> data to prevent
libcurl from doing strlen() (C-function, similar to string.len() in Lua)
on the data to figure out the size.</p>

	
<p>This is the large file version of the
<a href="##(curl).OPT_POSTFIELDSIZE">curl.OPT_POSTFIELDSIZE</a> option. (Added in 7.11.1) <br />
<br /> <em>needs:</em> #number</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).OPT_POSTQUOTE" >
<strong>curl.OPT_POSTQUOTE</strong>
</a>
</dt>
<dd>
	
<p>Pass a list of FTP or SFTP commands to pass to the server after your FTP transfer request.</p>

	
<p>The commands will only be run if no error occurred. The linked list should
be a fully valid list of struct curl_slist structs properly filled in as
described for <a href="##(curl).OPT_QUOTE">curl.OPT_QUOTE</a>. Disable this operation again by setting a #nil
to this option. <br />
<br /> <em>needs:</em> #string, ..., #string</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).OPT_PREQUOTE" >
<strong>curl.OPT_PREQUOTE</strong>
</a>
</dt>
<dd>
	
<p>Pass a list of FTP commands to pass to the server after the transfer type is set.</p>

	
<p>The linked list should be a fully valid list of properly filled in as described below.
Disable this operation again by setting a #nil to this option. Before
version 7.16.0, if you also set <a href="##(curl).OPT_NOBODY">curl.OPT_NOBODY</a> to true, this option
didn't work. <br />
<br />
The valid FTP commands are: <br />
+ chgrp <br />
+ chmod <br />
+ chown <br />
+ ln <br />
+ mkdir <br />
+ pwd <br />
+ rename <br />
+ rm <br />
+ rmdir <br />
+ symlink <br />
<br /> <em>needs:</em> #string, ..., #string</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).OPT_PROGRESSDATA" >
<strong>curl.OPT_PROGRESSDATA</strong>
</a>
</dt>
<dd>
	
<p>userparam of <a href="##(curl).OPT_PROGRESSFUNCTION">curl.OPT_PROGRESSFUNCTION</a>
<br /> <em>needs:</em> userparam</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).OPT_PROGRESSFUNCTION" >
<strong>curl.OPT_PROGRESSFUNCTION</strong>
</a>
</dt>
<dd>
	
<p>This function gets called by libcurl instead of its internal equivalent with
a frequent interval.</p>

	
<p>While data is being transferred it will be called very
frequently, and during slow periods like when nothing is being transferred
it can slow down to about one call per second. <br />
<br />
userparam is the pointer set with <a href="##(curl).OPT_PROGRESSDATA">curl.OPT_PROGRESSDATA</a>, it is not
actually used by libcurl but is only passed along from the application to
the callback. <br />
<br />
The callback gets told how much data libcurl will transfer and has
transferred, in #number of bytes. dltotal is the total #number of bytes
libcurl expects to download in this transfer. dlnow is the #number of bytes
downloaded so far. ultotal is the total #number of bytes libcurl expects to
upload in this transfer. ulnow is the #number of bytes uploaded so far. <br />
<br />
Unknown/unused argument values passed to the callback will be set to zero
(like if you only download data, the upload size will remain 0). Many times
the callback will be called one or more times first, before it knows the
data sizes so a program must be made to handle that. <br />
CURLOPT_NOPROGRESS must be set to 0 to make this function actually get called. <br />
<br /> <em>needs:</em> function(userparam, dltotal, dlnow, uptotal, upnow)
<br /> <em>returns:</em>  #number</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).OPT_PROXY" >
<strong>curl.OPT_PROXY</strong>
</a>
</dt>
<dd>
	
<p>IP-address of the proxy.</p>

	
<p>The proxy #string may be prefixed with [protocol]:// since any such prefix
will be ignored. The proxy's port #number may optionally be specified with
the separate option. If not specified, libcurl will default to using port
1080 for proxies. <a href="##(curl).OPT_PROXYPORT">curl.OPT_PROXYPORT</a>. <br />
<br />
When you tell the library to use a HTTP proxy, libcurl will transparently
convert operations to HTTP even if you specify an FTP URL etc. This may
have an impact on what other features of the library you can use, such as
<a href="##(curl).OPT_QUOTE">curl.OPT_QUOTE</a> and similar FTP specifics that don't work unless you tunnel
through the HTTP proxy. Such tunneling is activated with
<a href="##(curl).OPT_HTTPPROXYTUNNEL">curl.OPT_HTTPPROXYTUNNEL</a>. <br /> 
<br /> <em>needs:</em> #string</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).OPT_PROXYAUTH" >
<strong>curl.OPT_PROXYAUTH</strong>
</a>
</dt>
<dd>
	
<p>Pass a #number as parameter, which is set to a bitmask, to tell libcurl which
authentication method(s) you want it to use for your proxy authentication.</p>

	
<p>If more than one bit is set, libcurl will first query the site to see what
authentication methods it supports and then pick the best one you allow it
to use. For some methods, this will induce an extra network round-trip. Set
the actual name and password with the <a href="##(curl).OPT_PROXYUSERPWD">curl.OPT_PROXYUSERPWD</a> option. The
bitmask can be constructed by or'ing together the bits listed above for the
<a href="##(curl).OPT_HTTPAUTH">curl.OPT_HTTPAUTH</a> option. As of this writing, only Basic, Digest and NTLM work.
(Added in 7.10.7) <br />
<br /> <em>needs:</em> #number</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).OPT_PROXYPORT" >
<strong>curl.OPT_PROXYPORT</strong>
</a>
</dt>
<dd>
	
<p>Set the proxy port to connect to unless it is specified in the proxy #string <a href="##(curl).OPT_PROXY">curl.OPT_PROXY</a>.</p>

	
<p><br /> <em>needs:</em> #number</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).OPT_PROXYTYPE" >
<strong>curl.OPT_PROXYTYPE</strong>
</a>
</dt>
<dd>
	
<p>Available options for this are: <br />
+ <a href="##(curl).PROXY_HTTP">curl.PROXY_HTTP</a> <br />
+ <a href="##(curl).PROXY_HTTP_1_0">curl.PROXY_HTTP<em>1</em>0</a> (added in 7.19.4) <br />
+ <a href="##(curl).PROXY_SOCKS4">curl.PROXY_SOCKS4</a> (added in 7.10) <br />
+ <a href="##(curl).PROXY_SOCKS5">curl.PROXY_SOCKS5</a> <br />
+ <a href="##(curl).PROXY_SOCKS4A">curl.PROXY_SOCKS4A</a> (added in 7.18.0) <br />
+ <a href="##(curl).PROXY_SOCKS5_HOSTNAME">curl.PROXY<em>SOCKS5</em>HOSTNAME</a> (added in 7.18.0) <br />
The HTTP type is default.</p>

	
<p>(Added in 7.10)
If you set <a href="##(curl).OPT_PROXYTYPE">curl.OPT_PROXYTYPE</a> to <a href="##(curl).PROXY_HTTP_1_0">curl.PROXY_HTTP<em>1</em>0</a>, it will only
affect how libcurl speaks to a proxy when CONNECT is used. The HTTP version
used for "regular" HTTP requests is instead controlled with <a href="##(curl).OPT_HTTP_VERSION">curl.OPT<em>HTTP</em>VERSION</a>. <br />
<br /> <em>needs:</em> #number
<br /> <em>default:</em> <a href="##(curl).HTTP">curl.HTTP</a> (Added in 7.10)</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).OPT_PROXYUSERPWD" >
<strong>curl.OPT_PROXYUSERPWD</strong>
</a>
</dt>
<dd>
	
<p>The #string should be [user name]:[password] to use for the connection to the
HTTP proxy.</p>

	
<p><br />
Use <a href="##(curl).OPT_PROXYAUTH">curl.OPT_PROXYAUTH</a> to specify the authentication method. <br />
<br /> <em>needs:</em> #string</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).OPT_PUT" >
<strong>curl.OPT_PUT</strong>
</a>
</dt>
<dd>
	
<p>A #boolean set to true tells the library to use HTTP PUT to transfer data.</p>

	
<p>The data should be set with <a href="##(curl).OPT_READDATA">curl.OPT_READDATA</a> and <a href="##(curl).OPT_INFILESIZE">curl.OPT_INFILESIZE</a>. <br />
<br />
This option is deprecated and starting with version 7.12.1 you should
instead use <a href="##(curl).OPT_UPLOAD">curl.OPT_UPLOAD</a>. <br />
<br /> <em>needs:</em> #boolean</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).OPT_QUOTE" >
<strong>curl.OPT_QUOTE</strong>
</a>
</dt>
<dd>
	
<p>Pass a list of FTP or SFTP commands to pass to the server prior to your FTP request.</p>

	
<p>This will be done before any other commands are issued (even before the CWD
command for FTP). <br />
The list should be a fully valid list of one of the values below. <br />
Disable this operation again by setting a #nil to this option. When speaking
to a FTP (or SFTP since 7.24.0) server, prefix the command with an asterisk
(&#47;) to make libcurl continue even if the command fails as by default libcurl
will stop at first failure. <br />
<br />
The set of valid FTP commands depends on the server (see
<a target="_blank" href="http://tools.ietf.org/html/rfc959"> RFC 959 </a> for a list of
mandatory commands). <br />
<br />
The valid SFTP commands are: <br />
+ chgrp <br />
+ chmod <br />
+ chown <br />
+ ln <br />
+ mkdir <br />
+ pwd <br />
+ rename <br />
+ rm <br />
+ rmdir <br />
+ symlink <br />
(see curl (1); I don't know what that means... I can't find it...)
(SFTP support added in 7.16.3) <br />
<br /> <em>needs:</em> #string, ..., #string</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).OPT_RANDOM_FILE" >
<strong>curl.OPT_RANDOM_FILE</strong>
</a>
</dt>
<dd>
	
<p>Pass a file name.</p>

	
<p>The file will be used to read from to seed the random
engine for SSL. The more random the specified file is, the more secure the
SSL connection will become. <br />
<br /> <em>needs:</em> #string</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).OPT_RANGE" >
<strong>curl.OPT_RANGE</strong>
</a>
</dt>
<dd>
	
<p>Pass a #string as parameter, which should contain the specified range you want.</p>

	
<p>It should be in the format "X-Y", where X or Y may be left out. HTTP transfers
also support several intervals, separated with commas as in "X-Y,N-M".
Using this kind of multiple intervals will cause the HTTP server to send the
response document in pieces (using standard MIME separation techniques). For
RTSP, the formatting of a range should follow RFC 2326 Section 12.29. For RTSP,
byte ranges are not permitted. Instead, ranges should be given in npt, utc,
or smpte formats. <br />
<br />
Pass a #nil to this option to disable the use of ranges. <br />
<br />
Ranges work on HTTP, FTP, FILE (since 7.18.0), and RTSP (since 7.20.0) transfers only. <br />
<br /> <em>needs:</em> #string</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).OPT_READDATA" >
<strong>curl.OPT_READDATA</strong>
</a>
</dt>
<dd>
	
<p>userparam to pass to the file read function.</p>

	
<p>If you use the
<a href="##(curl).OPT_READFUNCTION">curl.OPT_READFUNCTION</a> if you set this option. <br />
This option was also known by the older name <a href="##(curl).OPT_INFILE">curl.OPT_INFILE</a>, the name
<a href="##(curl).OPT_READDATA">curl.OPT_READDATA</a> was introduced in 7.9.7. <br />
<br /> <em>needs:</em> userparam</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).OPT_READFUNCTION" >
<strong>curl.OPT_READFUNCTION</strong>
</a>
</dt>
<dd>
	
<p>This function gets called by libcurl as soon as it needs to read data in
order to send it to the peer.</p>

	
<p>Your function must return the actual #number
of bytes that you stored in that memory area. Returning 0 will signal
end-of-file to the library and cause it to stop the current transfer. <br />
<br />
If you stop the current transfer by returning 0 "pre-maturely"
(i.e before the server expected it, like when you've said you will upload N
bytes and you upload less than N bytes), you may experience that the server
"hangs" waiting for the rest of the data that won't come. <br />
<br />
The read callback may return <a href="##(curl).READFUNC_ABORT">curl.READFUNC_ABORT</a> to stop the current
operation immediately. <br />
<br />
<em>Bugs:</em> when doing TFTP uploads, you must return the exact amount of data
that the callback wants, or it will be considered the final packet by the
server end and the transfer will end there. <br />
<br /> <em>needs:</em> function(userparam, size)
<br /> <em>returns:</em> #string</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).OPT_REFERER" >
<strong>curl.OPT_REFERER</strong>
</a>
</dt>
<dd>
	
<p>It will be used to set the Referer:
header in the http request sent to the remote server.</p>

	
<p>This can be used to
fool servers or scripts. You can also set any custom header with
<a href="##(curl).OPT_HTTPHEADER">curl.OPT_HTTPHEADER</a>. <br />
<br /> <em>needs:</em> #string</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).OPT_RESUME_FROM" >
<strong>curl.OPT_RESUME_FROM</strong>
</a>
</dt>
<dd>
	
<p>The #number contains the offset in number of bytes that you want the transfer to start from.</p>

	
<p>Set this option to 0 to make the transfer start from the beginning
(effectively disabling resume). For FTP, set this option to -1 to make the
transfer start from the end of the target file (useful to continue an
interrupted upload). <br />
<br />
When doing uploads with FTP, the resume position is where in the local/source
file libcurl should try to resume the upload from and it will then append
the source file to the remote target file. <br />
<br /> <em>needs:</em> #number</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).OPT_RESUME_FROM_LARGE" >
<strong>curl.OPT_RESUME_FROM_LARGE</strong>
</a>
</dt>
<dd>
	
<p>The #number contains the offset in number of bytes that you want the transfer to start from.</p>

	
<p>(Added in 7.11.0) <br />
<br /> <em>needs:</em> #number</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).OPT_SOURCE_POSTQUOTE" >
<strong>curl.OPT_SOURCE_POSTQUOTE</strong>
</a>
</dt>
<dd>
	
<p>I cannot find anything about this...</p>

	
<p><br /> <em>needs:</em> #string, ..., #string</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).OPT_SOURCE_PREQUOTE" >
<strong>curl.OPT_SOURCE_PREQUOTE</strong>
</a>
</dt>
<dd>
	
<p>I cannot find anything about this...</p>

	
<p><br /> <em>needs:</em> #string, ..., #string</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).OPT_SOURCE_QUOTE" >
<strong>curl.OPT_SOURCE_QUOTE</strong>
</a>
</dt>
<dd>
	
<p>I cannot find anything about this...</p>

	
<p><br /> <em>needs:</em> #string, ..., #string</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).OPT_SOURCE_URL" >
<strong>curl.OPT_SOURCE_URL</strong>
</a>
</dt>
<dd>
	
<p>I cannot find anything about this...</p>

	
<p><br /> <em>needs:</em> #string</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).OPT_SOURCE_USERPWD" >
<strong>curl.OPT_SOURCE_USERPWD</strong>
</a>
</dt>
<dd>
	
<p>Login details #string for the connection.</p>

	
<p>The format of which is: [user name]:[password];[options]. <br />
When using NTLM, you can set the domain by prepending it to the user name
and separating the domain and name with a forward (/) or backward slash ().
Like this: "domain/user:password" or "domain\user:password". Some HTTP
servers (on Windows) support this style even for Basic authentication. <br />
<br />
When using HTTP and <a href="##(curl).OPT_FOLLOWLOCATION">curl.OPT_FOLLOWLOCATION</a>, libcurl might perform several
requests to possibly different hosts. libcurl will only send this user and
password information to hosts using the initial host name (unless
<a href="##(curl).OPT_UNRESTRICTED_AUTH">curl.OPT<em>UNRESTRICTED</em>AUTH</a> is set), so if libcurl follows locations to
other hosts it will not send the user and password to those. This is enforced
to prevent accidental information leakage. <br />
<br />
At present only IMAP, POP3 and SMTP support login options as part of the
details #string. For more information about the login options please see <a target="_blank" href="http://tools.ietf.org/html/rfc2384"> RFC 2384 </a>,
<a target="_blank" href="http://tools.ietf.org/html/rfc5092"> RFC5092 </a> and IETF draft <a target="_blank" href="http://tools.ietf.org/html/draft-earhart-url-smtp-00"> draft-earhart-url-smtp-00.txt </a> (Added in 7.31.0).
Use <a href="##(curl).OPT_HTTPAUTH">curl.OPT_HTTPAUTH</a> to specify the authentication method for HTTP
based connections. <br />
<br /> <em>needs:</em> #string</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).OPT_SSLCERT" >
<strong>curl.OPT_SSLCERT</strong>
</a>
</dt>
<dd>
	
<p>The #string should be the file name of your certificate.</p>

	
<p>The default format is "PEM" and can be changed with <a href="##(curl).OPT_SSLCERTTYPE">curl.OPT_SSLCERTTYPE</a>. <br />
<br />
With NSS this can also be the nickname of the certificate you wish to authenticate with. <br />
If you want to use a file from the current directory, please precede it with "./" prefix,
in order to avoid confusion with a nickname. <br />
<br />
(iOS and Mac OS X only) With Secure Transport, this string must match the name
of a certificate that's in the system or user keychain. You should encode this
string in UTF-8 format in case it contains non-ASCII characters. The private
key corresponding to the certificate, and certificate chain (if any), must
also be present in the keychain. (Added in 7.31.0) <br />
<br /> <em>needs:</em> #string</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).OPT_SSLCERTTYPE" >
<strong>curl.OPT_SSLCERTTYPE</strong>
</a>
</dt>
<dd>
	
<p>The #string should be the format of your certificate.</p>

	
<p>Supported formats are "PEM" and "DER". (Added in 7.9.3) 
<br /> <em>needs:</em> #string</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).OPT_SSLENGINE" >
<strong>curl.OPT_SSLENGINE</strong>
</a>
</dt>
<dd>
	
<p>It will be used as the identifier for the crypto engine you want to use for your private key.</p>

	
<p>If the crypto device cannot be loaded, <a href="##(curl).SSL_ENGINE_NOTFOUND">curl.SSL<em>ENGINE</em>NOTFOUND</a> is returned. <br />
<br /> <em>needs:</em> #string</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).OPT_SSLENGINE_DEFAULT" >
<strong>curl.OPT_SSLENGINE_DEFAULT</strong>
</a>
</dt>
<dd>
	
<p>Sets the actual crypto engine as the default for (asymmetric) crypto operations.</p>

	
<p>If the crypto device cannot be set, <a href="##(curl).SSL_ENGINE_SETFAILED">curl.SSL<em>ENGINE</em>SETFAILED</a> is returned.<br />
<br />
Even though this option doesn't need any parameter, in some configurations
<a href="##(curlobj).setopt">curlobj.setopt</a> might be defined as a macro taking exactly three arguments.
Therefore, it's recommended to pass 1 as parameter to this option. <br />
<br /> <em>needs:</em> #boolean</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).OPT_SSLKEY" >
<strong>curl.OPT_SSLKEY</strong>
</a>
</dt>
<dd>
	
<p>The #string should be the file name of your private key.</p>

	
<p>The default format is "PEM" and can be changed with <a href="##(curl).OPT_SSLKEYTYPE">curl.OPT_SSLKEYTYPE</a>. <br />
<br />
(iOS and Mac OS X only) This option is ignored if curl was built against
Secure Transport. Secure Transport expects the private key to be already
present in the keychain containing the certificate. <br />
<br /> <em>needs:</em> #string</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).OPT_SSLKEYPASSWD" >
<strong>curl.OPT_SSLKEYPASSWD</strong>
</a>
</dt>
<dd>
	
<p>It will be used as the password required to use the <a href="##(curl).OPT_SSLKEY">curl.OPT_SSLKEY</a> or
private key.</p>

	
<p>You never needed a pass phrase to load a certificate but you
need one to load your private key. <br />
<br /> <em>needs:</em> #string</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).OPT_SSLKEYTYPE" >
<strong>curl.OPT_SSLKEYTYPE</strong>
</a>
</dt>
<dd>
	
<p>The #string should be the format of your private key.</p>

	
<p>Supported formats are "PEM", "DER" and "ENG". <br />
<br />
The format "ENG" enables you to load the private key from a crypto engine.
In this case <a href="##(curl).OPT_SSLKEY">curl.OPT_SSLKEY</a> is used as an identifier passed to the
engine. You have to set the crypto engine with <a href="##(curl).OPT_SSLENGINE">curl.OPT_SSLENGINE</a>.
"DER" format key file currently does not work because of a bug in OpenSSL. <br />
<br /> <em>needs:</em> #string</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).OPT_SSLVERSION" >
<strong>curl.OPT_SSLVERSION</strong>
</a>
</dt>
<dd>
	
<p>Pass a number as parameter to control what version of SSL/TLS to attempt to use.</p>

	
<p><br />
<br />
<em>The available options are:</em> <br />
+ <a href="##(curl).SSLVERSION_DEFAULT">curl.SSLVERSION_DEFAULT</a> : The default action. This will attempt to
  figure out the remote SSL protocol version, i.e. either SSLv3 or TLSv1
  (but not SSLv2, which became disabled by default with 7.18.1). <br />
+ <a href="##(curl).CURL_SSLVERSION_TLSv1">curl.CURL<em>SSLVERSION</em>TLSv1</a> : Force TLSv1 <br />
+ <a href="##(curl).CURL_SSLVERSION_SSLv2">curl.CURL<em>SSLVERSION</em>SSLv2</a> : Force SSLv2 <br />
+ <a href="##(curl).CURL_SSLVERSION_SSLv3">curl.CURL<em>SSLVERSION</em>SSLv3</a> : Force SSLv3  <br />
<br /> <em>needs:</em> #number</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).OPT_SSL_CIPHER_LIST" >
<strong>curl.OPT_SSL_CIPHER_LIST</strong>
</a>
</dt>
<dd>
	
<p>Pass a #string holding the list of ciphers to use for the SSL connection.</p>

	
<p>The list must be syntactically correct, it consists of one or more cipher
strings separated by colons. Commas or spaces are also acceptable separators
but colons are normally used, !, - and + can be used as operators. <br />
<br />
For OpenSSL and GnuTLS valid examples of cipher lists include <br />
+ 'RC4-SHA' <br />
+ 'SHA1+DES' <br />
+ 'TLSv1' <br />
+ 'DEFAULT' <br />
The default list is normally set when you compile OpenSSL.
You'll find more details about cipher lists on this URL: <a target="_blank" href="http://www.openssl.org/docs/apps/ciphers.html">http://www.openssl.org/docs/apps/ciphers.html </a> <br />
<br />
For NSS, valid examples of cipher lists include 'rsa<em>rc4</em>128<em>md5',
'rsa</em>aes<em>128</em>sha', etc. With NSS you don't add/remove ciphers. If one uses
this option then all known ciphers are disabled and only those passed in
are enabled. <br />
<br />
You'll find more details about the NSS cipher lists on this URL:
<a target="_blank" href="http://git.fedorahosted.org/cgit/mod_nss.git/plain/docs/mod_nss.html#Directives">http://git.fedorahosted.org/cgit/mod<em>nss.git/plain/docs/mod</em>nss.html#Directives</a> <br /> 
<br /> <em>needs:</em> #string</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).OPT_SSL_VERIFYHOST" >
<strong>curl.OPT_SSL_VERIFYHOST</strong>
</a>
</dt>
<dd>
	
<p>This option determines whether libcurl verifies that the server cert is for the server it is known as.</p>

	
<p>When negotiating a SSL connection, the server sends a certificate indicating its identity. <br />
+ When <a href="##(curl).OPT_SSL_VERIFYHOST">curl.OPT<em>SSL</em>VERIFYHOST</a> is 2, that certificate must indicate that
the server is the server to which you meant to connect, or the connection fails. <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Curl considers the server the intended one when the Common Name field or a
Subject Alternate Name field in the certificate matches the host name in
the <a href="curl.OPT_URL.html">curl.OPT_URL</a> to which you told Curl to connect. <br />
+ When the value is 1, libcurl will return a failure. <br />
<br />
It was previously (in 7.28.0 and earlier) a debug option of some sorts, but
it is no longer supported due to frequently leading to programmer mistakes. <br />
<br />
When the value is 0, the connection succeeds regardless of the names in the certificate. <br />
<br />
This option controls checking the server's certificate's claimed identity.
The server could be lying. To control lying, see <a href="##(curl).OPT_SSL_VERIFYPEER">curl.OPT<em>SSL</em>VERIFYPEER</a>.
If libcurl is built against NSS and <a href="##(curl).OPT_SSL_VERIFYPEER">curl.OPT<em>SSL</em>VERIFYPEER</a> is false, <a href="##(curl).OPT_SSL_VERIFYHOST">curl.OPT<em>SSL</em>VERIFYHOST</a> is ignored. 
<br /> <em>needs:</em> #number
<br /> <em>default:</em> 2</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).OPT_SSL_VERIFYPEER" >
<strong>curl.OPT_SSL_VERIFYPEER</strong>
</a>
</dt>
<dd>
	
<p>This option determines whether curl verifies the authenticity of the peer's certificate.</p>

	
<p>true means curl verifies; false means it doesn't. <br />
<br />
When negotiating a SSL connection, the server sends a certificate indicating
its identity. Curl verifies whether the certificate is authentic, i.e. that
you can trust that the server is who the certificate says it is. This trust
is based on a chain of digital signatures, rooted in certification authority
(CA) certificates you supply. curl uses a default bundle of CA certificates
(the path for that is determined at build time) and you can specify alternate
certificates with the <a href="##(curl).OPT_CAINFO">curl.OPT_CAINFO</a> option or the <a href="##(curl).OPT_CAPATH">curl.OPT_CAPATH</a> option. <br />
<br />
When <a href="##(curl).OPT_SSL_VERIFYPEER">curl.OPT<em>SSL</em>VERIFYPEER</a> is true, and the verification fails to
prove that the certificate is authentic, the connection fails. When the
option is false, the peer certificate verification succeeds regardless. <br />
<br />
Authenticating the certificate is not by itself very useful. You typically
want to ensure that the server, as authentically identified by its certificate
is the server you mean to be talking to. Use <a href="##(curl).OPT_SSL_VERIFYHOST">curl.OPT<em>SSL</em>VERIFYHOST</a> to
control that. The check that the host name in the certificate is valid for
the host name you're connecting to is done independently of the <a href="##(curl).OPT_SSL_VERIFYPEER">curl.OPT<em>SSL</em>VERIFYPEER</a> option. <br />
<br /> <em>needs:</em> #boolean
<br /> <em>default:</em> true</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).OPT_TCP_NODELAY" >
<strong>curl.OPT_TCP_NODELAY</strong>
</a>
</dt>
<dd>
	
<p>Pass a #number specifying whether the <a href="##(curl).OPT_TCP_NODELAY">curl.OPT<em>TCP</em>NODELAY</a> option is to be set or
cleared (true = set, false = clear).</p>

	
<p>This will have no effect after the
connection has been established. <br />
<br />
Setting this option will disable TCP's Nagle algorithm. The purpose of this
algorithm is to try to minimize the #number of small packets on the network
(where "small packets" means TCP segments less than the Maximum Segment Size
(MSS) for the network). <br />
<br />
Maximizing the amount of data sent per TCP segment is good because it
amortizes the overhead of the send. However, in some cases (most notably
telnet or rlogin) small segments may need to be sent without delay. This is
less efficient than sending larger amounts of data at a time, and can
contribute to congestion on the network if overdone. <br />
<br /> <em>needs:</em> #boolean
<br /> <em>default:</em> false</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).OPT_TELNETOPTIONS" >
<strong>curl.OPT_TELNETOPTIONS</strong>
</a>
</dt>
<dd>
	
<p>Provide a pointer to a list with variables to pass to the telnet negotiations.</p>

	
<p>The variables should be in the format <option=value>. libcurl supports the
options 'TTYPE', 'XDISPLOC' and 'NEW_ENV'. See the TELNET standard for details. <br />
<br /> <em>needs:</em> #string, ..., #string</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).OPT_TIMECONDITION" >
<strong>curl.OPT_TIMECONDITION</strong>
</a>
</dt>
<dd>
	
<p>This defines how the <a href="##(curl).OPT_TIMEVALUE">curl.OPT_TIMEVALUE</a> time value is treated.</p>

	
<p>You can set this parameter to <a href="##(curl).TIMECOND_IFMODSINCE">curl.TIMECOND_IFMODSINCE</a> or <a href="##(curl).TIMECOND_IFUNMODSINCE">curl.TIMECOND_IFUNMODSINCE</a>.
This feature applies to HTTP, FTP, RTSP, and FILE. <br />
<br />
The last modification time of a file is not always known and in such
instances this feature will have no effect even if the given time condition
would not have been met. <br />
<br /> <em>needs:</em> #number</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).OPT_TIMEOUT" >
<strong>curl.OPT_TIMEOUT</strong>
</a>
</dt>
<dd>
	
<p>Pass a #number as parameter containing the maximum time in seconds that you
allow the libcurl transfer operation to take.</p>

	
<p>Normally, name lookups can take a considerable time and limiting operations
to less than a few minutes risk aborting perfectly normal operations. This
option will cause curl to use the SIGALRM to enable time-outing system calls. <br />
<br />
In unix-like systems, this might cause signals to be used unless
<a href="##(curl).OPT_NOSIGNAL">curl.OPT_NOSIGNAL</a> is set. <br />
<br />
Default timeout is 0 (zero) which means it never times out. <br />
<br /> <em>needs:</em> #number</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).OPT_TIMEVALUE" >
<strong>curl.OPT_TIMEVALUE</strong>
</a>
</dt>
<dd>
	
<p>This should be the time in seconds since 1 Jan 1970,
and the time will be used in a condition as specified with <a href="##(curl).OPT_TIMECONDITION">curl.OPT_TIMECONDITION</a>.</p>

	
<p><br />
<br /> <em>needs:</em> #number</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).OPT_TRANSFERTEXT" >
<strong>curl.OPT_TRANSFERTEXT</strong>
</a>
</dt>
<dd>
	
<p>A #boolean set to true tells the library to use ASCII mode for FTP
transfers, instead of the default binary transfer.</p>

	
<p>For win32 systems it does
not set the stdout to binary mode. This option can be usable when
transferring text data between systems with different views on certain
characters, such as newlines or similar. <br />
<br />
libcurl does not do a complete ASCII conversion when doing ASCII transfers
over FTP. This is a known limitation/flaw that nobody has rectified. libcurl
simply sets the mode to ASCII and performs a standard transfer. <br /> 
<br /> <em>needs:</em> #boolean</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).OPT_UNRESTRICTED_AUTH" >
<strong>curl.OPT_UNRESTRICTED_AUTH</strong>
</a>
</dt>
<dd>
	
<p>A #boolean set to true tells the library it can continue to send
authentication (user+password) when following locations, even when hostname
changed.</p>

	
<p>This option is meaningful only when setting <a href="##(curl).OPT_FOLLOWLOCATION">curl.OPT_FOLLOWLOCATION</a>. <br /> 
<br /> <em>needs:</em> #boolean</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).OPT_UPLOAD" >
<strong>curl.OPT_UPLOAD</strong>
</a>
</dt>
<dd>
	
<p>A parameter set to 1 tells the library to prepare for an upload.</p>

	
<p>The
<a href="##(curl).OPT_READDATA">curl.OPT_READDATA</a> and <a href="##(curl).OPT_INFILESIZE">curl.OPT_INFILESIZE</a> or <a href="##(curl).OPT_INFILESIZE_LARGE">curl.OPT<em>INFILESIZE</em>LARGE</a>
options are also interesting for uploads. If the protocol is HTTP, uploading
means using the PUT request unless you tell libcurl otherwise. <br />
<br />
Using PUT with HTTP 1.1 implies the use of a "Expect: 100-continue" header.
You can disable this header with <a href="##(curl).OPT_HTTPHEADER">curl.OPT_HTTPHEADER</a> as usual. <br />
<br />
If you use PUT to a HTTP 1.1 server, you can upload data without knowing the
size before starting the transfer if you use chunked encoding. You enable
this by adding a header like "Transfer-Encoding: chunked" with <a href="##(curl).OPT_HTTPHEADER">curl.OPT_HTTPHEADER</a>.
With HTTP 1.0 or without chunked transfer, you must specify the size. <br />
<br /> <em>needs:</em> #boolean</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).OPT_URL" >
<strong>curl.OPT_URL</strong>
</a>
</dt>
<dd>
	
<p>The URL used to receive/send data.</p>

	
<p><br /> <em>needs:</em> #string</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).OPT_USERAGENT" >
<strong>curl.OPT_USERAGENT</strong>
</a>
</dt>
<dd>
	
<p>It will be used to set the User-Agent:
header in the http request sent to the remote server.</p>

	
<p>This can be used to
fool servers or scripts. You can also set any custom header with
<a href="##(curl).OPT_HTTPHEADER">curl.OPT_HTTPHEADER</a>. <br />
<br /> <em>needs:</em> #string</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).OPT_USERPWD" >
<strong>curl.OPT_USERPWD</strong>
</a>
</dt>
<dd>
	
<p><br /> <em>needs:</em> #string</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).OPT_VERBOSE" >
<strong>curl.OPT_VERBOSE</strong>
</a>
</dt>
<dd>
	
<p>Set the parameter to true to get the library to display a lot of verbose
information about its operations.</p>

	
<p>Very useful for libcurl and/or protocol
debugging and understanding. The verbose information will be sent to stderr.
You hardly ever want this set in production use, you will almost always want
this when you debug/report problems.
<br /> <br /> <em>needs:</em> #boolean
<br /> <em>default:</em> false</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).OPT_WRITEDATA" >
<strong>curl.OPT_WRITEDATA</strong>
</a>
</dt>
<dd>
	
<p>userparam to pass to the file write function.</p>

	
<p>If you use the
<a href="##(curl).OPT_WRITEFUNCTION">curl.OPT_WRITEFUNCTION</a> option, this is the pointer you'll get as input. <br />
<br />
<em>NOTE:</em> If you're using libcurl as a win32 DLL, you MUST use the
<a href="##(curl).OPT_WRITEFUNCTION">curl.OPT_WRITEFUNCTION</a> if you set this option or you will experience crashes. <br />
<br />
This option is also known with the older name CURLOPT<em>FILE, the name
CURLOPT</em>WRITEDATA was introduced in 7.9.7. <br />
The written data (a table)
<br /> <em>needs:</em> userparam</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).OPT_WRITEFUNCTION" >
<strong>curl.OPT_WRITEFUNCTION</strong>
</a>
</dt>
<dd>
	
<p>This function gets called by libcurl as soon as there is data received that
needs to be saved.</p>

	
<p>Return the #number of bytes actually taken care of. If
that amount differs from the amount passed to your function, it'll signal an
error to the library. This will abort the transfer and return
<a href="##(curl).WRITE_ERROR">curl.WRITE_ERROR</a>. <br />
This function may be called with zero bytes data if the transferred file is empty. <br />
Set this option to #nil to get the internal default function. The internal
default function will write the data to the userparam given with <a href="##(curl).OPT_WRITEDATA">curl.OPT_WRITEDATA</a>. <br />
Set the userdata argument with the <a href="##(curl).OPT_WRITEDATA">curl.OPT_WRITEDATA</a> option.
The callback function will be passed as much data as possible in all invokes,
but you cannot possibly make any assumptions. It may be one byte, it may be
thousands. <br />
<br /> <em>needs:</em> function(userparam, buffer)
<br /> <em>returns:</em>  #number</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).OPT_WRITEINFO" >
<strong>curl.OPT_WRITEINFO</strong>
</a>
</dt>
<dd>
	
<p>I am not sure...</p>

	
<p>I can't do anything with it, but it says it sets write informations.
It is given in the <a target="_blank" href="http://luacurl.luaforge.net/">documentation</a>, that it needs a string... but there is nochting more about it
<br /> <em>needs:</em> #string</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).OUT_OF_MEMORY" >
<strong>curl.OUT_OF_MEMORY</strong>
</a>
</dt>
<dd>
	
<p>Its a selfdescribing error...</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).PARTIAL_FILE" >
<strong>curl.PARTIAL_FILE</strong>
</a>
</dt>
<dd>
	
<p>Its a selfdescribing error...</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).PROXY_HTTP" >
<strong>curl.PROXY_HTTP</strong>
</a>
</dt>
<dd>
	
<p>HTTP-type proxy <br />
Used for <a href="##(curl).OPT_PROXYTYPE">curl.OPT_PROXYTYPE</a></p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).PROXY_SOCKS4" >
<strong>curl.PROXY_SOCKS4</strong>
</a>
</dt>
<dd>
	
<p>SOCKS4-type proxy <br />
Used for <a href="##(curl).OPT_PROXYTYPE">curl.OPT_PROXYTYPE</a></p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).PROXY_SOCKS5" >
<strong>curl.PROXY_SOCKS5</strong>
</a>
</dt>
<dd>
	
<p>SOCKS5-type proxy <br />
Used for <a href="##(curl).OPT_PROXYTYPE">curl.OPT_PROXYTYPE</a></p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).PTRCONTENTS" >
<strong>curl.PTRCONTENTS</strong>
</a>
</dt>
<dd>
	
<p>The actual data to send away.</p>

	
<p>libcurl will use the pointer and refer to the data in your application, so
you must make sure it remains until curl no longer needs it. If the data
isn't NUL-terminated, or if you'd like it to contain zero bytes, you must
set its length with <a href="##(curl).CONTENTSLENGTH">curl.CONTENTSLENGTH</a>. <br />
<br /> <em>needs:</em> #table</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).PTRNAME" >
<strong>curl.PTRNAME</strong>
</a>
</dt>
<dd>
	
<p>The #string provides the pointer-name.</p>

	
<p>libcurl will use the pointer and refer to the data in your application, so
you must make sure it remains until curl no longer needs it. <br />
<br /> <em>needs:</em> #string</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).READFUNC_ABORT" >
<strong>curl.READFUNC_ABORT</strong>
</a>
</dt>
<dd>
	
<p>Aborts the read-function.</p>

	
<p>I can't really say if its usefull in Lua, as Lua does not provide cross-thread
used variables in threading...</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).READ_ERROR" >
<strong>curl.READ_ERROR</strong>
</a>
</dt>
<dd>
	
<p>Its a selfdescribing error...</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).SEND_ERROR" >
<strong>curl.SEND_ERROR</strong>
</a>
</dt>
<dd>
	
<p>Its a selfdescribing error...</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).SEND_FAIL_REWIND" >
<strong>curl.SEND_FAIL_REWIND</strong>
</a>
</dt>
<dd>
	
<p>Its a selfdescribing error...</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).SHARE_IN_USE" >
<strong>curl.SHARE_IN_USE</strong>
</a>
</dt>
<dd>
	
<p>Its a selfdescribing error...</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).SSLVERSION_DEFAULT" >
<strong>curl.SSLVERSION_DEFAULT</strong>
</a>
</dt>
<dd>
	
<p>The default action.</p>

	
<p>This will attempt to figure out the remote SSL protocol version, i.e. either
SSLv3 or TLSv1 (but not SSLv2, which became disabled by default with 7.18.1). <br />
Used for <a href="##(curl).OPT_SSLVERSION">curl.OPT_SSLVERSION</a></p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).SSLVERSION_SSLv2" >
<strong>curl.SSLVERSION_SSLv2</strong>
</a>
</dt>
<dd>
	
<p>Force SSLv2 <br />
Used for <a href="##(curl).OPT_SSLVERSION">curl.OPT_SSLVERSION</a></p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).SSLVERSION_SSLv3" >
<strong>curl.SSLVERSION_SSLv3</strong>
</a>
</dt>
<dd>
	
<p>Force SSLv3 <br />
Used for <a href="##(curl).OPT_SSLVERSION">curl.OPT_SSLVERSION</a></p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).SSLVERSION_TLSv1" >
<strong>curl.SSLVERSION_TLSv1</strong>
</a>
</dt>
<dd>
	
<p>Force TLSv1 <br />
Used for <a href="##(curl).OPT_SSLVERSION">curl.OPT_SSLVERSION</a></p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).SSL_CACERT" >
<strong>curl.SSL_CACERT</strong>
</a>
</dt>
<dd>
	
<p>Its a selfdescribing error...</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).SSL_CERTPROBLEM" >
<strong>curl.SSL_CERTPROBLEM</strong>
</a>
</dt>
<dd>
	
<p>Its a selfdescribing error...</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).SSL_CIPHER" >
<strong>curl.SSL_CIPHER</strong>
</a>
</dt>
<dd>
	
<p>Its a selfdescribing error...</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).SSL_CONNECT_ERROR" >
<strong>curl.SSL_CONNECT_ERROR</strong>
</a>
</dt>
<dd>
	
<p>Its a selfdescribing error...</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).SSL_ENGINE_INITFAILED" >
<strong>curl.SSL_ENGINE_INITFAILED</strong>
</a>
</dt>
<dd>
	
<p>Its a selfdescribing error...</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).SSL_ENGINE_NOTFOUND" >
<strong>curl.SSL_ENGINE_NOTFOUND</strong>
</a>
</dt>
<dd>
	
<p>Its a selfdescribing error...</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).SSL_ENGINE_SETFAILED" >
<strong>curl.SSL_ENGINE_SETFAILED</strong>
</a>
</dt>
<dd>
	
<p>Its a selfdescribing error...</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).SSL_PEER_CERTIFICATE" >
<strong>curl.SSL_PEER_CERTIFICATE</strong>
</a>
</dt>
<dd>
	
<p>UNDOCUMENTED/NOTHING FOUND</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).TELNET_OPTION_SYNTAX" >
<strong>curl.TELNET_OPTION_SYNTAX</strong>
</a>
</dt>
<dd>
	
<p>Its a selfdescribing error...</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).TIMECOND_IFMODSINCE" >
<strong>curl.TIMECOND_IFMODSINCE</strong>
</a>
</dt>
<dd>
	
<p>Condition: If modified since ?</p>

	
<p><br />
Used for <a href="##(curl).OPT_TIMECONDITION">curl.OPT_TIMECONDITION</a></p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).TIMECOND_IFUNMODSINCE" >
<strong>curl.TIMECOND_IFUNMODSINCE</strong>
</a>
</dt>
<dd>
	
<p>Condition: If unmodified since ?</p>

	
<p><br />
Used for <a href="##(curl).OPT_TIMECONDITION">curl.OPT_TIMECONDITION</a></p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).TIMECOND_LASTMOD" >
<strong>curl.TIMECOND_LASTMOD</strong>
</a>
</dt>
<dd>
	
<p>Condition: last modified <br />
Used for <a href="##(curl).OPT_TIMECONDITION">curl.OPT_TIMECONDITION</a></p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).TIMECOND_NONE" >
<strong>curl.TIMECOND_NONE</strong>
</a>
</dt>
<dd>
	
<p>No time condition <br />
Used for <a href="##(curl).OPT_TIMECONDITION">curl.OPT_TIMECONDITION</a></p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).TOO_MANY_REDIRECTS" >
<strong>curl.TOO_MANY_REDIRECTS</strong>
</a>
</dt>
<dd>
	
<p>Its a selfdescribing error...</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).UNKNOWN_TELNET_OPTION" >
<strong>curl.UNKNOWN_TELNET_OPTION</strong>
</a>
</dt>
<dd>
	
<p>Its a selfdescribing error...</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).UNSUPPORTED_PROTOCOL" >
<strong>curl.UNSUPPORTED_PROTOCOL</strong>
</a>
</dt>
<dd>
	
<p>Its a selfdescribing error...</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).URL_MALFORMAT" >
<strong>curl.URL_MALFORMAT</strong>
</a>
</dt>
<dd>
	
<p>Its a selfdescribing error...</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).URL_MALFORMAT_USER" >
<strong>curl.URL_MALFORMAT_USER</strong>
</a>
</dt>
<dd>
	
<p>Its a selfdescribing error...</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#number</em>
<a id="#(curl).WRITE_ERROR" >
<strong>curl.WRITE_ERROR</strong>
</a>
</dt>
<dd>
	
<p>Its a selfdescribing error...</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#string</em>
<a id="#(curl)._COPYRIGHT" >
<strong>curl._COPYRIGHT</strong>
</a>
</dt>
<dd>
	
<p>Copyright information of this module.</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#string</em>
<a id="#(curl)._CURLVERSION" >
<strong>curl._CURLVERSION</strong>
</a>
</dt>
<dd>
	
<p>The current used CURL version for this module.</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#string</em>
<a id="#(curl)._DESCRIPTION" >
<strong>curl._DESCRIPTION</strong>
</a>
</dt>
<dd>
	
<p>A description of this module.</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#string</em>
<a id="#(curl)._NAME" >
<strong>curl._NAME</strong>
</a>
</dt>
<dd>
	
<p>The name of this module.</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#string</em>
<a id="#(curl)._SUPPORTED_CURLVERSION" >
<strong>curl._SUPPORTED_CURLVERSION</strong>
</a>
</dt>
<dd>
	
<p>The supported CURL version of this module.</p>

</dd>
</dl>
		<dl class="function">
<dt>

		<em>#string</em>
<a id="#(curl)._VERSION" >
<strong>curl._VERSION</strong>
</a>
</dt>
<dd>
	
<p>The current version of luacurl.</p>

</dd>
</dl>
		<dl class="function">
<dt>

<a id="#(curl).escape" >
<strong>curl.escape(url)</strong>
</a>
</dt>
<dd>
	
<p>Escapes URL #strings.</p>

		<h3>Parameter</h3>
		<ul>
				<li>
				
<p><code><em>#string url </em></code>: 
the url to escape</p>

				</li>
		</ul>
		<h3>Return value</h3>
				
<p><em><a href="##(curlobj)">#curlobj</a>:</em>
the curl-object to perfom your actions on.</p>


</dd>
</dl>
		<dl class="function">
<dt>

<a id="#(curl).new" >
<strong>curl.new()</strong>
</a>
</dt>
<dd>
	
<p>Use this function to instantiate curl objects.</p>

		<h3>Return value</h3>
				
<p><em><a href="##(curlobj)">#curlobj</a>:</em>
the curl-object to perfom your actions on.</p>


</dd>
</dl>
		<dl class="function">
<dt>

<a id="#(curl).unescape" >
<strong>curl.unescape(url)</strong>
</a>
</dt>
<dd>
	
<p>Unescapes URL encoding in #strings. </p>

		<h3>Parameter</h3>
		<ul>
				<li>
				
<p><code><em>#string url </em></code>: 
the url to unescape</p>

				</li>
		</ul>
		<h3>Return value</h3>
				
<p><em><a href="##(curlobj)">#curlobj</a>:</em>
the curl-object to perfom your actions on.</p>


</dd>
</dl>

			<h2><a id="#(curlobj)" >Type <code>curlobj</code></a></h2>
				<h3>Field(s)</h3>
		<dl class="function">
<dt>

<a id="#(curlobj).close" >
<strong>curlobj.close()</strong>
</a>
</dt>
<dd>
	
<p>This function closes a curl connection created by <a href="##(curl).new">curl.new</a></p>

</dd>
</dl>
		<dl class="function">
<dt>

<a id="#(curlobj).getinfo" >
<strong>curlobj.getinfo(info)</strong>
</a>
</dt>
<dd>
	
<p>Get informations for the <a href="##(curlobj)">#curlobj</a>.</p>

		<h3>Parameter</h3>
		<ul>
				<li>
				
<p><code><em>#number info </em></code>: 
infofield of <a href="##(curl)">#curl</a> (curl.INFO_???) (e.g. <a href="##(curl).INFO_CONNECT_TIME">curl.INFO<em>CONNECT</em>TIME</a>)</p>

				</li>
		</ul>
		<h3>Return value</h3>
				

<p>the information</p>


</dd>
</dl>
		<dl class="function">
<dt>

<a id="#(curlobj).perform" >
<strong>curlobj.perform()</strong>
</a>
</dt>
<dd>
	
<p>Call this method to perform a file transfer after all <a href="##(curlobj).setopt">curlobj.setopt</a> calls are made.</p>

</dd>
</dl>
		<dl class="function">
<dt>

<a id="#(curlobj).setopt" >
<strong>curlobj.setopt(option, ...)</strong>
</a>
</dt>
<dd>
	
<p>Sets options for the <a href="##(curlobj)">#curlobj</a> to be used on the <a href="##(curlobj).perform">curlobj.perform</a> function.</p>

		<h3>Parameters</h3>
		<ul>
				<li>
				
<p><code><em>#number option </em></code>: 
A field of the curl module (e.g. <a href="##(curl).OPT_AUTOREFERER">curl.OPT_AUTOREFERER</a>)</p>

				</li>
				<li>
				
<p><code><em> ... </em></code>: 
parameter for the option (See the curl.OPT_??? fields for more information)</p>

				</li>
		</ul>
		<h3>Return value</h3>
				

<p>optional return. They will be given in the OPT_??? descriptions.</p>


</dd>
</dl>

</div>

</div>
</body>
</html>
